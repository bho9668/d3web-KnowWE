import java.util.*;
import java.text.*;
import java.util.logging.Logger;
import de.d3web.kernel.domainModel.*;
import de.d3web.kernel.domainModel.qasets.*;
import de.d3web.textParser.Utils.Message;
import de.d3web.kernel.supportknowledge.*;
import de.d3web.kernel.domainModel.formula.FormulaNumber;
import de.d3web.kernel.domainModel.ruleCondition.*;
import de.d3web.kernel.domainModel.answers.*;
import de.d3web.kernel.domainModel.formula.FormulaExpression;
import de.d3web.textParser.Utils.*;
import de.d3web.textParser.decisionTable.MessageGenerator;
import de.d3web.kernel.psMethods.*;
import de.d3web.kernel.psMethods.heuristic.*;
import de.d3web.kernel.psMethods.nextQASet.*;


/**
 * Im Gegensatz zum QContainerHierarchy-Parser und zum DiagnosisHierarchy-Parser wird hier keine Map mehr benutzt,
 * um die zuletzt eingelesenen, relevanten Zeilen-Elemente zu speichern.
 * In diesem Parser wurde vielmehr die Möglichkeit von Coco ausgenutzt, in den EBNF-Produktionen Eingabe- sowie
 * Ausgabeparameter zu gebrauchen.
 * Weiterhin wurde die Token-Struktur verbessert, der Parser ignoriert nun wieder per default Spaces,
 * dies hat den Vorteil, das darauf nicht mehr geachtet werden muss, bzw. den Spaces nun keine syntaktische Funktion abverlangt wird.
 * Im Zuge einer Verbesserung der beiden anderen, oben genannten Parser könnte man die hier verwendete Struktur dort auch umsetzen.
 * 
 * @author Franz Schwab
 */

COMPILER DecisionTree

	
	private KnowledgeBase kb;
	private KnowledgeBaseManagement kbm;
	private boolean addMode;
	
	private int numberOfInsertedQuestions = 0;
	private int numberOfInsertedFollowingQuestions = 0;
    private int numberOfInsertedQContainerIndications = 0;
	private int numberOfInsertedDiagnosisDerivations = 0;
	private int numberOfInsertedQContainerIndicationsByDiagnosis = 0;
	
	public List<Message> successMessages = new LinkedList<Message>();
	
	//Stack to remember path to leaf for create complex conditions (conjunctions)
	private Stack<TerminalCondition> conditionStack = new Stack<TerminalCondition>();
	private boolean complexPathConditions = true;
	
	private HashMap<Question,Integer> questionCounts = new HashMap<Question,Integer>();
	private boolean uniqueQuestionNames = true;
	
    private static final ResourceBundle rb = ResourceBundle.getBundle("properties.textParser");
    
    //Begin Change Extension
    private String content = ""; 
	private NamedObject namedObject = null; 
	private AnswerChoice answer = null; 
	private HashMap<String,ArrayList<Object>> mapNamedObjects = new HashMap<String,ArrayList<Object>>(); 
	private HashMap<String,ArrayList<Object>> mapAnswers = new HashMap<String,ArrayList<Object>>();
	private ArrayList<String> abbr = new ArrayList<String>(); 
	private ArrayList<String> allowedNames = new ArrayList<String>(); 
	private ArrayList<NamedObject> savedLinks = new ArrayList<NamedObject>(); 
	//End Change Extension
    
    /**
     * Setzt die Zähler für die geparsten Elemente zurück
     */
    private void resetNumberCounter() {
	    this.numberOfInsertedQuestions = 0;
	    this.numberOfInsertedFollowingQuestions = 0;
		this.numberOfInsertedQContainerIndications = 0;
		this.numberOfInsertedDiagnosisDerivations = 0;
		this.numberOfInsertedQContainerIndicationsByDiagnosis = 0;
	}
	
    /**
     * Erstellt eine Meldung.
     * @param row Zeile in der Eingabe-Datei
     * @param column Spalte  in der Eingabe-Datei
     * @param key Schlüssel der Meldung
     * @param messageType Message.ERROR, Message.WARNING oder MESSAGE.Note
     * @param values Parameter, welche in den Text der Meldung mit aufgenommen werden sollen
     */
    private void createMessage(
            int row, int column, String key, String messageType, Object ... values) {
        String result = rb.getString("parser.error.unknownError") + ": "+key;
        try {
            result = MessageFormat.format(
                rb.getString(key), values);
        }
        catch (MissingResourceException e) {}
        errors.Error(row, column, result, messageType);        
    }
    
    private void createDiagnosisUnknownError(
            int row, int column, String key, String messageType, Object ... values) {
        String result = rb.getString("parser.error.unknownError") + ": "+key;
        try {
            result = MessageFormat.format(
                rb.getString(key), values);
        }
        catch (MissingResourceException e) {}
        ConceptNotInKBError err = new ConceptNotInKBError(messageType, result, null, row,column, null );
        if(values !=  null && values.length > 0) {
        	err.setObjectName((String)values[0]);
        }
        err.setKey(MessageGenerator.KEY_INVALID_DIAGNOSIS);
        errors.Error(err);   
    }
    
    private void createDiagnosisOrSIUnknownError(
            int row, int column, String key, String messageType, Object ... values) {
        String result = rb.getString("parser.error.unknownError") + ": "+key;
        try {
            result = MessageFormat.format(
                rb.getString(key), values);
        }
        catch (MissingResourceException e) {}
        ConceptNotInKBError err = new ConceptNotInKBError(messageType, result, null, row,column, null );
        if(values !=  null && values.length > 0) {
        	err.setObjectName((String)values[0]);
        }
        err.setKey(MessageGenerator.KEY_INVALID_DIAGNOSIS);
        errors.Error(err);   
    }
	
    /**
     * Fügt eine Erfolgsmeldung zur Liste hinzu (pro Frageklasse)
     * @param qContainer Name der Frageklasse
     */
    public void addSuccessNote(String qContainer) {
        Object[] values = {
        	qContainer,
		    this.numberOfInsertedQuestions,
		    this.numberOfInsertedFollowingQuestions,
			this.numberOfInsertedQContainerIndications,
			this.numberOfInsertedDiagnosisDerivations,
			this.numberOfInsertedQContainerIndicationsByDiagnosis
    	};
        String result = rb.getString("parser.error.unknownError");
        try {
            result = MessageFormat.format(
                rb.getString("parser.decisionTree.success"), values);
        }
        catch (MissingResourceException e) {}
        successMessages.add(new Message(Message.NOTE, result, "", 0,0,""));
        
        resetNumberCounter();
    }
    
    /**
     * Formatiert den Bezeichner einer Frageklasse, entfernen von Whitespace am Anfang und Ende sowie der Anführungszeichen
     * @param decl unformatierter Name der Frageklasse
     * @return formatierter Name der Frageklasse
     */
    private String formatDeclaration(String decl) {
        // fehler besser abfangen: java.lang.StringIndexOutOfBoundsException: String index out of range: 0
		decl = decl.trim();
		try {
			if (decl.charAt(0) == '\"'
					&& decl.charAt(decl.length() - 1) == '\"') {
				decl = decl.substring(1, decl.length() - 1);
			}
		} catch(StringIndexOutOfBoundsException e) {
			createMessage(t.line, t.col,
					"parser.decisionTree.error.formatDeclaration",
					Message.ERROR);
		}
		return decl;
	}
    
    /**
     * Überprüft, ob das Ende der zu parsenden Datei erreicht ist
     * @return true: Ende ist nicht erreicht, false: Ende ist erreicht
     */
    private boolean isNotEOF() {
		scanner.ResetPeek();
    	Token x = la;
    	while (x.kind == _newline) {
    		x = scanner.Peek();
    	}
    	return x.kind != _EOF;
    }
    
    /**
     * Überprüft, ob in der nächsten Zeile eine Frage der Ebene 1 (1 Dash) steht, also direkt in einer Frageklasse enthalten ist.
     * @return true: ist Frage der ersten Ebene, false: ist nicht Frage der ersten Ebene
     */
    private boolean isFirstLevelQuestion() {
		scanner.ResetPeek();
    	Token x = la;
    	while (x.kind == _newline) {
    		x = scanner.Peek();
    	}
    	return x.kind == _dash && scanner.Peek().kind != _dash;
    }
    
    
    /**
     * Überprüft, ob die nächste Zeile eine bestimmte Anzahl an Anführungsstrichen vorweisen kann.
     * @param dashes Anzahl der Dashes, auf die in der nächsten Zeile überprüft werden soll
     * @return true: geforderte Anzahl liegt vor, false: geforderte Anzahl liegt nicht vor.
     */
    private boolean properAmountOfDashes(int dashes) {
		scanner.ResetPeek();
    	int thisDashes = 0;
    	Token x = la;
    	while (x.kind == _newline) {
			x = scanner.Peek();
		}
    	while (x.kind == _dash) {
    		x = scanner.Peek();
    		thisDashes++;
    	}
    	return thisDashes == dashes;
    }
    
    
    /**
     * zählt die Anführungsstriche der nächsten Zeile
     * @return Anzahl der Anführungsstriche der nächsten Zeile
     */
    private int countDashes() {
		scanner.ResetPeek();
    	int countDashes = 0;
    	Token x = la;
		while (x.kind == _newline) {
			x = scanner.Peek();
		}
		while (x.kind == _dash) {
			x = scanner.Peek();
			countDashes++;
		}
		return countDashes;
	}
	
	/**
	 * Überprüft, ob der String c der Anfang des Tokens ist, der nach dem gerade betrachteten Declaration-Tokens kommt.
	 * Es geht darum zu überprüfen, ob in der gleichen Zeile der Declaration noch ein Token kommt, der z.B. auf einen Fragetyp hinweist. 
	 * @param c der zu suchende String
	 * @param t der aktuelle Token
	 * @return true: der String c wurde als Anfang des nächsten Tokens gefunden, ansonsten false
	 */
	private boolean isFirstNonDeclarationToken(String c, Token t) {
		scanner.ResetPeek();
		while (t.kind != _dash) {
			t = scanner.Peek();
		}
		while (t.kind == _dash) {
			t = scanner.Peek();
		}
		Token sp = scanner.Peek();
		boolean result = ((t.kind==_declaration)&& sp.val.startsWith(c));
		return result;
	}
	
	/**
	 * "handle"-Methoden sind ausgelagerte Methoden, um die syntaktische EBNF im *.atg-File klarer von den semantischen Aktionen zu trennen.
	 * Dies ist eine Handle-Methode für die semantische Behandlung einer Frageklassen-Definition.
	 * Bei allen folgenden handle-Methoden weist die Bezeichnung darauf hin, wo sie in der Syntax eingesetzt wird.
	 * Es werden nur noch Parameter und return-Typen angegeben.
	 * @param q Token des aktuellen, zu suchenden QContainers
	 * @return der QContainer
	 */
	private QContainer handleQContainerDefinition(Token q) {
		resetNumberCounter();
		QContainer qc = null;
		String declaration = q.val.trim();
		declaration = formatDeclaration(q.val);
		qc = kbm.findQContainer(declaration);
		if (qc == null) {
			createMessage(q.line, q.col,
			"parser.decisionTree.error.qContainerNotFound",
			Message.ERROR, declaration);
		}
		if (addMode && (qc.getChildren().size() > 0)) {
			createMessage(q.line, q.col,
			"parser.decisionTree.error.update.qContainerNotEmpty",
			Message.ERROR, declaration);
		}
		return qc;
	}
	
	/**
	 * @param q abstrakte Frage
	 */
	private void handleQuestionAbstract(Question q) {
		q.getProperties().setProperty(Property.ABSTRACTION_QUESTION, true);
	}
	
	/**
	 * @param intervalLeft linke Intervall-Grenze, eingeschlossen
	 * @param intervalRight rechte Intervall-Grenze, eingeschlossen
	 * @param d Name der numerischen Frage
	 * @param unit Einheit des Antworten-Bereichs
	 * @param q Vater-QASet
	 * @return die Frage, die erzeugt wurde
	 */
	private Question handleQuestionNum(Double intervalLeft,
			Double intervalRight, String d, String unit, QASet q) {

		//if question already exists take existing one else create new
		Question question = kbm.findQuestion(d);
		countQuestionAppearence(question);
		QuestionNum currentQuestion = null;
		if (this.uniqueQuestionNames && question != null && (question instanceof QuestionNum)) {
			currentQuestion = (QuestionNum)question;
			q.addChild(currentQuestion);
			
		}else {
			currentQuestion = kbm.createQuestionNum(d, q);
		}
		
		if (unit != null)
			currentQuestion.getProperties().setProperty(Property.UNIT, unit);
		if (intervalLeft != null && intervalRight != null) {
			NumericalInterval range = new NumericalInterval(intervalLeft,
					intervalRight);
			currentQuestion.getProperties().setProperty(
					Property.QUESTION_NUM_RANGE, range);
		}
		this.numberOfInsertedQuestions++;
		return currentQuestion;
	}
	
	public HashMap<Question,Integer> getQuestionCounts() {
		return this.questionCounts;
	}
	
	//counts how often the same questions appeared in decTree for reporting
	private void countQuestionAppearence(Question question) {
		if(question == null) return;
		if(questionCounts.containsKey(question)) {
			Integer cnt = questionCounts.get(question);
			questionCounts.put(question, new Integer(cnt.intValue()+1));
		}else {
			questionCounts.put(question, new Integer(2));
		}
	}
	
	/**
	 * @param d Name der OC-Frage
	 * @param q Vater-QASet
	 * @return die erzeugte Frage
	 */
	private Question handleQuestionOC(String d, QASet q) {
//		if question already exists take existing one else create new
		Question question = kbm.findQuestion(d);
		countQuestionAppearence(question);
		QuestionOC currentQuestion = null;
		if (this.uniqueQuestionNames && question != null && (question instanceof QuestionOC)) {
			currentQuestion = (QuestionOC)question;
			q.addChild(currentQuestion);
			
		}else {
			currentQuestion = kbm.createQuestionOC(d, q,
					new AnswerChoice[] {});
		}
		this.numberOfInsertedQuestions++;
		return currentQuestion;
	}
	
		/**
	 * @param d Name der ZC-Frage
	 * @param q Vater-QASet
	 * @return die erzeugte Frage
	 */
	private Question handleQuestionZC(String d, QASet q) {
//		if question already exists take existing one else create new
		Question question = kbm.findQuestion(d);
		countQuestionAppearence(question);
		QuestionZC currentQuestion = null;
		if (this.uniqueQuestionNames && question != null && (question instanceof QuestionZC)) {
			currentQuestion = (QuestionZC)question;
			q.addChild(currentQuestion);
			
		}else {
			currentQuestion = kbm.createQuestionZC(d, q);
		}
		this.numberOfInsertedQuestions++;
		return currentQuestion;
	}
	
	/**
	 * @param d Declaration der MC-Frage
	 * @param q Vater-QASet
	 * @return erzeugte Frage
	 */
	private Question handleQuestionMC(String d, QASet q) {
//		if question already exists take existing one else create new
		Question question = kbm.findQuestion(d);
		countQuestionAppearence(question);
		QuestionMC currentQuestion = null;
		if (this.uniqueQuestionNames && question != null && (question instanceof QuestionMC)) {
			currentQuestion = (QuestionMC)question;
			q.addChild(currentQuestion);
			
		}else {
			currentQuestion = kbm.createQuestionMC(d, q,
					new AnswerChoice[] {});
		}
		this.numberOfInsertedQuestions++;
		return currentQuestion;
	}
	
	/**
	 * wird wohl erstmal nicht gebraucht, die gesamte QuestionDate-Behandlung wird auch von knowme noch nicht unterstützt
	 * @param d Declaration der Date-Frage
	 * @param q Vater-QASet
	 * @return erzeugte Frage
	 */
	private Question handleQuestionDate(String d, QASet q) {
//		if question already exists take existing one else create new
		Question question = kbm.findQuestion(d);
		countQuestionAppearence(question);
		QuestionDate currentQuestion = null;
		if (this.uniqueQuestionNames && question != null && (question instanceof QuestionDate)) {
			currentQuestion = (QuestionDate)question;
			q.addChild(currentQuestion);
			
		}else {
			currentQuestion = kbm.createQuestionDate(d, q);
		}
		
		this.numberOfInsertedQuestions++;
		return currentQuestion;
	}
	
	/**
	 * @param d Declaration der Text-Frage
	 * @param q Vater-QASet
	 * @return erzeugte Frage
	 */
	private Question handleQuestionText(String d, QASet q) {
//		if question already exists take existing one else create new
		Question question = kbm.findQuestion(d);
		countQuestionAppearence(question);
		QuestionText currentQuestion = null;
		if (this.uniqueQuestionNames && question != null && (question instanceof QuestionText)) {
			currentQuestion = (QuestionText)question;
			q.addChild(currentQuestion);
			
		}else {
			currentQuestion = kbm.createQuestionText(d, q);
		}
		this.numberOfInsertedQuestions++;
		return currentQuestion;
	}
	
	/**
	 * @param d Declaration der YN-Frage
	 * @param q Vater-QASet
	 * @return erzeugte Frage
	 */
	private Question handleQuestionYN(String d, QASet q) {
//		if question already exists take existing one else create new
		Question question = kbm.findQuestion(d);
		countQuestionAppearence(question);
		QuestionYN currentQuestion = null;
		if (this.uniqueQuestionNames && question != null && (question instanceof QuestionYN)) {
			currentQuestion = (QuestionYN)question;
			q.addChild(currentQuestion);
			
		}else {
			currentQuestion = kbm.createQuestionYN(d, q);
		}
		
		this.numberOfInsertedQuestions++;
		return currentQuestion;
	}
	
	/**
	 * handled für AnswerNum den Comparator; anstatt möglicher Methode "handleAnswerNum()".
	 * Behandelt Vergleiche mit nur einem numerischen Wert als Antwort
	 * @param q die Frage, für die der Vergleich durchgeführt werden soll
	 * @param doubleValue der Wert, mit dem verglichen werden soll
	 */
	private void handleComparison(Question q, Token doubleValue) {
		NumericalInterval range = (NumericalInterval) q.getProperties().getProperty(Property.QUESTION_NUM_RANGE);
		double answerValue = Double.parseDouble(doubleValue.val.replaceAll("," , "."));
	    if(range != null && !range.contains(answerValue))
	        createMessage(t.line, t.col,
			"parser.decisionTree.error.notMatchingInterval1",
			Message.ERROR, answerValue);
	}
	
	/**
	 * handled für AnswerNum den Comparator; anstatt möglicher Methode "handleAnswerNum()".
	 * Behandelt Vergleiche mit zwei numerischen Werten als Antwort-Berich (Intervall)
	 * @param q die Frage, für die der Vergleich durchgeführt werden soll
	 * @param doubleValueLeft linke Grenze, mit der verglichen werden soll
	 * @param doubleValueRight rechte Grenze, mit der verglichen werden soll
	 */
	private void handleComparison(Question q, Token doubleValueLeft, Token doubleValueRight) {
		NumericalInterval range = (NumericalInterval) q.getProperties().getProperty(Property.QUESTION_NUM_RANGE);
		double answerValueLeft = Double.parseDouble(doubleValueLeft.val.replaceAll("," , "."));
		double answerValueRight = Double.parseDouble(doubleValueRight.val.replaceAll("," , "."));
	    if(range != null && !(range.contains(answerValueLeft)&&range.contains(answerValueRight)))
	        createMessage(t.line, t.col,
			"parser.decisionTree.error.notMatchingInterval2",
			Message.ERROR, answerValueLeft, answerValueRight);
	}
	
	/**
	 * @param q Frage
	 * @param t Token der AnswerChoice
	 * @return AbstractCondition, welche in die KB eingefügt wurde. null, wenn ein Fehler auftrat.
	 */
	private TerminalCondition handleAnswerChoice(Question q, Token t, String id) {
		AnswerChoice acSearch = kbm.findAnswerChoice((QuestionChoice)q, t.val.trim());
		if (acSearch == null) {
			String declaration = formatDeclaration(t.val);
			if(!id.startsWith(q.getId())) {
				id = q.getId() + id;
			}
			acSearch = AnswerFactory.createAnswerChoice(id, declaration);
			acSearch.setQuestion(q);
			QuestionChoice qc = (QuestionChoice)q;
			qc.addAlternative(acSearch);
			// Begin Change Extension
			answer = acSearch;
			// End Change Extension
			
		} 
		CondEqual c = new CondEqual((QuestionChoice)q, acSearch);
		return c;
	}
	
	/**
	 * wird wohl erstmal nicht gebraucht, die gesamte QuestionDate-Behandlung wird auch von knowme noch nicht unterstützt
	 * @param q Frage
	 * @param t Token der AnswerDate
	 * @return AbstractCondition, welche in die KB eingefügt wurde
	 */
	private TerminalCondition handleAnswerDate(Question q, Token t) {
//		String declaration = formatDeclaration(t.val);
//		AnswerDate answerDate = new AnswerDate();
//		//COCO: todo!
//		//TODO: todo!
//		DateFormat d = new SimpleDateFormat();
//		answerDate.setValue(d.parse(declaration));
//		answerDate.setQuestion(q);
//		// Begin Change Extension
//		answer = (AnswerChoice)answerDate; 
//      // End Change Extension
//		// diese Methode gibts noch nicht
//		CondEqual c = new CondEqual(q, answerDate);
		return null;
	}
	
	/**
	 * @param q Frage
	 * @param t Token der AnswerText
	 * @return AbstractCondition, welche in die KB eingefügt wurde
	 */
	private TerminalCondition handleAnswerText(Question q, Token t) {
		String declaration = formatDeclaration(t.val);
		AnswerText answerText = new AnswerText();
		answerText.setText(declaration);
		answerText.setQuestion(q);
//		answer = (AnswerChoice)answerText; 
		CondTextEqual c = new CondTextEqual((QuestionText)q, declaration);
		return c;
	}
	
	/**
	 * @param q Frage
	 * @param declaration Declaration der AnswerYes
	 * @return AbstractCondition, welche in die KB eingefügt wurde
	 */
	private TerminalCondition handleAnswerYes(Question q) {
		// Begin Change Extension
		answer = ((QuestionYN)q).yes; 
		// End Change Extension
		CondChoiceYes c = new CondChoiceYes((QuestionYN)q);
		return c;
	}
	
	/**
	 * @param q Frage
	 * @param declaration Declaration der AnswerNo
	 * @return AbstractCondition, welche in die KB eingefügt wurde
	 */
	private TerminalCondition handleAnswerNo(Question q) {
		// Begin Change Extension
		answer = ((QuestionYN)q).no; 
		// Begin Change Extension
		CondChoiceNo c = new CondChoiceNo((QuestionYN)q);
		return c;
	}
	
	/**
	 * @param q Frage
	 * @param declaration Declaration der AnswerUnknown
	 * @return AbstractCondition, welche in die KB eingefügt wurde
	 */
	private TerminalCondition handleAnswerUnknown(Question q) {
		CondUnknown c = new CondUnknown(q);
		return c;
	}
	
	/**
	 * @param c Kondition
	 * @param ql Frageliste, die mit dem Feuern der Kondition indiziert wird
	 */
	private void handleQuestionIndication(List ql) {

		if (ql.size() > 0) {
			AbstractCondition cond = conditionStack.peek();
			if(this.complexPathConditions) {
				cond = getActualPathConjunction();
			}

			if (cond != null) {
				String newRuleID = kbm.findNewIDFor(new RuleComplex());
				RuleFactory.createIndicationRule(newRuleID, ql, cond);
			} else {
				createMessage(t.line, t.col,
						"parser.decisionTree.error.conditionNull",
						Message.ERROR, t.val);
			}
		}

		this.numberOfInsertedFollowingQuestions++;
	}
	
	/**
	 * @param c Kondition
	 * @param t Token der Frageklasse, die mit dem Feuern der Kondition indiziert wird
	 */
	private void handleQContainerIndication(List qcl) {
		if (qcl.size() > 0) {
			AbstractCondition cond = conditionStack.peek();
			if(this.complexPathConditions) {
				cond = getActualPathConjunction();
			}
			String newRuleID = kbm.findNewIDFor(new RuleComplex());
			if (cond != null) {
				List <Question> ql = filterQuestions(qcl);
				qcl.removeAll(ql);
				
				if(qcl.size() > 0) {
				RuleFactory.createIndicationRule(newRuleID, qcl, cond);
				}
				
				for (Question question : ql) {
					RuleFactory.createIndicationRule(newRuleID, question, cond);
				}
				
				this.numberOfInsertedQContainerIndications += qcl.size();
			} else {
				createMessage(
						t.line,
						t.col,
						"no path condition found on descend to qcontainer indication rule",
						Message.ERROR);
			}
		}
	}
	
	private List<Question> filterQuestions(List qcl) {
		List<Question> ql = new ArrayList<Question>();
		for (Object object : qcl) {
			if(object instanceof Question) {
				ql.add((Question)object);
			}
		}
		return ql;
	}

	
	/**
	 * Generiert eine Konjunktion über alle TConds auf dem Pfad von der Wurzel
	 * bis zum actuellen element.
	 */
	private AbstractCondition getActualPathConjunction() {
		AbstractCondition cond = null;
		if (this.conditionStack.size() == 1) {
			cond = conditionStack.get(0);
		} else if (this.conditionStack.size() > 1) {
			cond = new CondAnd(new ArrayList(this.conditionStack));
		} else {
			createMessage(
					t.line,
					t.col,
					"no condition found on descend to diagnosis indication rule",
					Message.ERROR);
		}
		return cond;
	}
	
	/**
	 * @param c Kondition 
	 * @param declarationToken Declaration der Diagnose, welche mit dem Feuern der Kondition indiziert wird
	 * @param indicationStrengthToken Token, der die Indikations-Stärke repräsentiert
	 * @return die gefundene Diagnose
	 */
	private Diagnosis handleDiagnosisIndication(Token declarationToken,
			Token indicationStrengthToken) {
				String declaration = formatDeclaration(declarationToken.val);
		Diagnosis diagnosis = kbm.findDiagnosis(declaration);
		String indicationStrength = formatDeclaration(indicationStrengthToken.val);
		if (diagnosis != null) {
			AbstractCondition cond = conditionStack.peek();
			if (this.complexPathConditions) {
				cond = getActualPathConjunction();
			}

			if (cond != null) {
				String newRuleID = kbm.findNewIDFor(new RuleComplex());
				RuleFactory.createHeuristicPSRule(newRuleID, diagnosis,
						ScoreFinder.getScore(indicationStrength), cond);
				return diagnosis;
			} else {
				createMessage(
						t.line,
						t.col,
						"no actual condition found on descend to diagnosis indication rule",
						Message.ERROR, declaration);
			}
			// numberOfCreatedDiagnosisRules++;
		} else {
			String name = declarationToken.val.trim();
			Question q = kbm.findQuestion(name);
			boolean set = false;
			if (q == null && name.endsWith("SET")) {
				q = kbm.findQuestion(name.substring(0, name.length() - 3)
						.trim());
				set = true;
			}
			if (q != null) {
				String newRuleID = kbm.findNewIDFor(new RuleComplex());
				// if (q instanceof QuestionNum) {
				// QuestionNum qNum = ((QuestionNum) q);
				// }

				AbstractCondition cond = conditionStack.peek();
				if (this.complexPathConditions) {
					cond = getActualPathConjunction();
				}
				if (cond != null) {
					

					if (q instanceof QuestionNum) {
						double d = 0;
						try {
							d = Double.parseDouble(indicationStrengthToken.val);
						} catch (Exception e) {
							createMessage(t.line, t.col, "invalid.Value",
									Message.ERROR, indicationStrengthToken.val);
						}
						FormulaNumber num = new FormulaNumber(d);
						FormulaExpression e = new FormulaExpression(
								(QuestionNum) q, num);

						if (set) {
							RuleFactory.createSetValueRule(newRuleID,
									(QuestionNum) q, e, cond);
						} else {
							RuleFactory.createAddValueRule(newRuleID,
									(QuestionNum) q, new Object[] { e }, cond);
						}
					} else if (q instanceof QuestionChoice) {
						AnswerChoice a = kbm.findAnswerChoice((QuestionChoice)q, indicationStrengthToken.val);
						if(a != null) {
							RuleFactory.createSetValueRule(newRuleID, q, new Object[] {a}, cond, null);
						}else {
							createMessage(
									t.line,
									t.col,
									indicationStrengthToken.val+" is not a valid answer for: "+q.toString(),
									Message.ERROR, declaration);
						}
					}
					return null;
				} else {
					createMessage(
							t.line,
							t.col,
							"no actual condition found on descend to diagnosis indication rule",
							Message.ERROR, declaration);
				}
			} else if (q != null && q instanceof QuestionChoice) {

			} else {
				createDiagnosisOrSIUnknownError(t.line, t.col,
						"parser.decisionTree.error.diagnosisOrSINotFound",
						Message.ERROR, declaration);
			}
		}
		this.numberOfInsertedDiagnosisDerivations++;
		return null;
	}
	
	/**
	 * Hier wird einer Liste von Frageklassen eine weitere Frageklasse hinzugefügt.
	 * @param declarationToken Declaration des QContainers (Frageklasse)
	 * @param qcl Frageklassen-Liste
	 */
	private void handleQContainerAccumulation(Token declarationToken, List qcl) {
		String declaration = formatDeclaration(declarationToken.val);
		String refPrefix = "&REF";
		if(declaration.startsWith(refPrefix)) {
			String referencedQuestionname = declaration.substring(refPrefix.length()).trim();
			Question q = kbm.findQuestion(referencedQuestionname);
			if(q == null) {
				createMessage(t.line, t.col,
					"parser.decisionTree.error.questionNotFound",
					Message.ERROR, referencedQuestionname);
			}else {
				qcl.add(q);
				return;
			}
		}
		QContainer qc = kbm.findQContainer(declaration);
		if (qc != null) {
			qcl.add(qc);
		} else {
			createMessage(t.line, t.col,
					"parser.decisionTree.error.qContainerNotFound",
					Message.ERROR, declaration);
		}
	}
	
	/**
	 * @param d Diagnose, welche eine Liste von Frageklassen indizieren soll.
	 * @param indicationStrengthToken Token der Indikations-Stärke
	 * @param qcl Liste der Frageklassen
	 */
	private void handleQContainerIndicationByDiagnosis(Diagnosis d, Token indicationStrengthToken, List qcl) {
		if (qcl.size() > 0) {
			String declarationStrength = formatDeclaration(indicationStrengthToken.val);
			Score score = ScoreFinder.getScore(declarationStrength);
			if (d != null) {
				List ruleList = d.getKnowledge(PSMethodNextQASet.class, MethodKind.FORWARD);
				// sollte normalerweise immer nur eine Regel haben!!!
				List existingQcl = null;
				if (ruleList != null){
					RuleComplex rc = (RuleComplex) ruleList.get(0);
					ActionNextQASet ra = (ActionNextQASet) rc.getAction();
					existingQcl = ra.getQASets();
				}
				// Die Regel muss erzeugt werden
				if(existingQcl == null || existingQcl.isEmpty()) {
					String newRuleID = kbm.findNewIDFor(new RuleComplex());
					if (score.compareTo(Score.P6) >= 0) {
						AbstractCondition c = new CondDState(d, DiagnosisState.ESTABLISHED, PSMethodHeuristic.class);
						RuleFactory.createRefinementRule(newRuleID, qcl, d, c);
					} else if (score.compareTo(Score.P3) >= 0) {
						AbstractCondition c = new CondDState(d, DiagnosisState.SUGGESTED, PSMethodHeuristic.class);
						RuleFactory.createClarificationRule(newRuleID, qcl, d, c);
					} else {
						AbstractCondition c = new CondDState(d, DiagnosisState.UNCLEAR, PSMethodHeuristic.class);
						RuleFactory.createIndicationRule(newRuleID, qcl, c);
						createMessage(t.line, t.col,
								"parser.decisionTree.warning.diagnosisStateUnclear",
								Message.WARNING, d.getText(), score.toString());
					}
					this.numberOfInsertedQContainerIndicationsByDiagnosis++;
				// Es muß ein Fehler geworfen werden, da die Listen nicht übereinstimmen!
				} else {
					boolean bool1 = existingQcl.containsAll(qcl);
					boolean bool2 = qcl.containsAll(existingQcl);
					if ( ! (bool1 && bool2)) {
						createMessage(t.line, t.col, "parser.decisionTree.error.differentQCLists", Message.ERROR, d.getText());
					} // else: Die Regel muss nicht erzeugt werden, da die Liste der QContainer übereinstimmt und bereits eine Regel existiert
				}
			} else {
				createMessage(t.line, t.col,
						"parser.decisionTree.error.diagnosisNotFound",
						Message.ERROR, "null");
			}
		}
	}
	
	private void handleQuestionIdentifier(Question q, String id){
		id = id.substring(1, id.length());
		id = id.trim();
		Question qSearch = kbm.findQuestion(id);
		if (qSearch == null) {
			q.setId(id);
		} else if (qSearch != q) {
			createMessage(t.line, t.col, "parser.decisionTree.error.idAlreadyExists", Message.ERROR, q.getText(), id);
		}
	}
	
	private String handleAnswerChoiceIdentifier(String id) {
		id = id.substring(1, id.length());
		id = id.trim();
		return id;
	}	
	
	//Begin Change Extension
	private void addMMInfo(NamedObject o,String title,String subject,String content){
		if(o == null) return;
		MMInfoStorage mmis; 
		DCMarkup dcm = new DCMarkup();
		dcm.setContent(DCElement.TITLE, title);
		dcm.setContent(DCElement.SUBJECT, subject);
		dcm.setContent(DCElement.SOURCE, o.getId());
		MMInfoObject mmi = new MMInfoObject(dcm, content); 
		if(o.getProperties().getProperty(Property.MMINFO) == null){
			mmis = new MMInfoStorage(); 
		}
		else{
			mmis = (MMInfoStorage)o.getProperties().getProperty(Property.MMINFO);
		}
		o.getProperties().setProperty(Property.MMINFO, mmis);
		mmis.addMMInfo(mmi);		
	}
	
	private String change(String decl){
		if(decl.equals("Durchf\u00fchrung")){
			decl = "realisation";
		}
		else if(decl.equals("Kurze Erkl\u00e4rung")){
			decl = "shortDescription"; 
		}
		else if(decl.equals("Lange Erkl\u00e4rung")){
			decl = "longDescription"; 
		}
		else if(decl.equals("Beispiele")){
			decl = "examples";
		}
		else if(decl.equals("Erl\u00e4terung")){
			decl = "explanation";
		}
		return decl; 
	}
	
	private String revChange(String decl){
		if(decl.equals("realisation")){
			decl = "Durchf\u00fchrung";
		}
		else if(decl.equals("shortDescription")){
			decl = "Kurze Erkl\u00e4rung"; 
		}
		else if(decl.equals("longDescription")){
			decl = "Lange Erkl\u00e4rung"; 
		}
		else if(decl.equals("examples")){
			decl = "Beispiele";
		}
		else if(decl.equals("explanation")){
			decl = "Erl\u00e4terung";
		}
		return decl; 
	}
	
	private QuestionChoice getQuestion(AnswerChoice a){
		Iterator iter = kb.getQuestions().iterator(); 
		while(iter.hasNext()){
			Question question = (Question)iter.next();
			if(question instanceof QuestionChoice){ 
				QuestionChoice q = (QuestionChoice)question;
				Iterator iteranswer = q.getAllAlternatives().iterator();
					while(iteranswer.hasNext()){
						AnswerChoice answer = (AnswerChoice)iteranswer.next(); 
						if(a.equals(answer)){
							return q; 
						}
					}
			}
		}
		return null; 
	}
	private void setAnswerContent(AnswerChoice a, String content){
		QuestionChoice q = getQuestion(a); 
		if(q != null){
			Iterator iteranswer = q.getAllAlternatives().iterator();
			while(iteranswer.hasNext()){
				AnswerChoice answer = (AnswerChoice)iteranswer.next(); 
				if(a.equals(answer)){
					answer.getProperties().setProperty(Property.EXPLANATION, content);
				}
			}
		}
	}
	
	//End Change Extension
	
	//Begin Text Extension
    private void setPrompt(String d, String prompt)
    {       
        Question q = kbm.findQuestion(d);
        
        if(q == null) {
        createMessage(
				t.line,
				t.col,
				"question not found in knnowledgebase for setting prompt: "+d,
				Message.ERROR);
        	Logger.getLogger(this.getClass().getName()).severe("ERROR ON SETTING PROMPT: question not found in knnowledgebase for setting prompt: "+d);
        	return;
        }
           
        MMInfoStorage storage;
        
        if(q.getProperties().getProperty(Property.MMINFO) == null){
            storage = new MMInfoStorage(); 
        }
        else{
            storage = (MMInfoStorage)q.getProperties().getProperty(Property.MMINFO);
        }
    
        DCMarkup markup = new DCMarkup();
        markup.setContent(DCElement.SOURCE, q.getId());
        markup.setContent(DCElement.SUBJECT, MMInfoSubject.PROMPT.getName());      
        
        storage.addMMInfo(new MMInfoObject(markup, prompt));
        q.getProperties().setProperty(Property.MMINFO, storage);
    }
    //End Text Extension
	
CHARACTERS
newline                  = '\n' + '\r'.
zeroDigit                = '0'.
digitWithoutZero         = "123456789".
digit                    = zeroDigit + digitWithoutZero.

allowedDeclaration = ANY - '-' - '\n' - '\r' - '\"' - '[' - ']' - '(' - ')' - '{' - '}' - '<' - '>' - '=' - '#' - '@' - '|'.
allowedDeclarationFurther = allowedDeclaration + '-' + '~'.
allowedDeclarationNoSpace = allowedDeclaration - ' '.
allowedDeclarationFurtherNoSpace = allowedDeclarationFurther - ' '.
allowedDeclarationNoDigitNoSpace = allowedDeclarationNoSpace - digit.
allowedDeclarationFurtherWithBrackets = allowedDeclarationFurther + '\n' + '\r' + '[' + ']' + '(' + ')' + '{' + '}' + '<' + '>' + '=' + '#'.


commentChar = ANY - newline.
//extChar     = ANY - '|'.

TOKENS


declaration			= (allowedDeclarationNoDigitNoSpace)
					| (allowedDeclarationNoDigitNoSpace {allowedDeclarationFurther} allowedDeclarationFurther)
//					| (allowedDeclarationNoSpace {allowedDeclarationFurther}allowedDeclarationFurtherNoDigitNoSpace)
//					| (allowedDeclarationNoSpace {allowedDeclarationFurther}allowedDeclarationFurtherNoDigitNoSpace{allowedDeclarationFurther}allowedDeclarationFurtherNoSpace)
// Begin Change Extension 
// | ('\"' allowedDeclarationFurtherWithBrackets {allowedDeclarationFurtherWithBrackets} '\"')
					| ('\"' allowedDeclarationFurtherWithBrackets {allowedDeclarationFurtherWithBrackets} ['\"']).
// End Change Extension
			
				
number				= ['-'](zeroDigit | digitWithoutZero{digit}) [('.' | ',') {digit}].
newline				= newline.
dash				= '-'.
parenthesisOpen     = '('.
parenthesisClose	= ')'.
bracketOpen			= '['.
bracketClose		= ']'.
ID					= '#'allowedDeclaration{allowedDeclaration}.

// Begin Change Extension
descriptionId		= '@'allowedDeclarationFurther{allowedDeclarationFurther} .
allowedNames 		= ( "##allowedNames" | "##AllowedNames" ).
// End Change Extension


PRAGMAS
comment = "//"{commentChar}(newline){newline}.



// Die Token-Struktur wurde hier verbessert, der Parser ignoriert per default Spaces.
// Dies hat den Vorteil, das darauf nicht mehr geachtet werden muss, bzw. den Spaces nun keine syntaktische Funktion abverlangt wird.
// (siehe Frame-Dateien)
IGNORE '\t'





PRODUCTIONS

DecisionTree			=	{newline} QContainerDefinition
{IF(isNotEOF() && properAmountOfDashes(0)) Separator (QContainerDefinition | { { AllowedNames {newline}} '|'Description'|'} )}
{newline}  EOF.

QContainerDefinition    = (Declaration											(.
																				String qContainerName = formatDeclaration(t.val);
																				QContainer q = handleQContainerDefinition(t);
																				.)																				
Question<out Question thisQ, q>
{IF(isFirstLevelQuestion())Question<out thisQ, q>}
)
																				(.
																				addSuccessNote(qContainerName);
																				.)
.

Question<out Question thisQ, QASet q> =
Separator																		(.
																				int l = countDashes();
																				.)
Dashes																				
Declaration                          										(.
																				thisQ = null;
																				String d = "";
																				String prompt = "";
																				if(t.val.contains("~")){
																				    String one = t.val.substring(0, t.val.indexOf("~")-1);
																				    String two = t.val.substring(t.val.indexOf("~")+1);
																				    if(one.startsWith("\"")) {
		    																			one = one.substring(1);
		    																		}
		    																		if(two.endsWith("\"")) {
		    																			two = two.substring(0,two.length()-1);
		    																		}
																				    d = formatDeclaration(one);
																				    prompt = formatDeclaration(two);
																				}else{
																				    d = formatDeclaration(t.val);
																				}
																				.)																	
(
QuestionNum<out thisQ, d, q, l>
| QuestionOC<out thisQ, d, q, l>
| QuestionMC<out thisQ, d, q, l>
| QuestionDate<out thisQ, d, q, l>
| QuestionText<out thisQ, d, q, l>
| QuestionYN<out thisQ, d, q, l>
| QuestionZC<out thisQ, d, q, l>
)
{IF(properAmountOfDashes(l + 1))Question<out Question directChildQ, thisQ>}     
                                                                                (.
                                                                                if(!prompt.equals("") && !d.equals("")){
                                                                                    setPrompt(d, prompt);
                                                                                }
                                                                                .)
.

QuestionNum<out Question thisQ, String d, QASet q, int l>	= "[num]"			(.
																				String unit = null;
																				.)
[
'{' Unit																		(.
																				unit = formatDeclaration(t.val);
																				.)
'}'
]
																				(.
																				Double intervalLeft = null;
																				Double intervalRight = null;
																				.)
[
'('
number																			(.
																				intervalLeft = Double.valueOf(t.val.replaceAll("," , "."));
																				.)
number																			(.																				
																				intervalRight = Double.valueOf(t.val.replaceAll("," , "."));
																				.)
')'																				
]																				(.
																				thisQ = handleQuestionNum(intervalLeft, intervalRight, d, unit, q);
																				// Begin Change Extension
																				namedObject = thisQ;
																				// End Change Extension
																				.)
{ DescriptionIdQuestion }
[IsAbstract<thisQ>]
[QuestionIdentifier<thisQ>]																																		
{IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerNum<thisQ>}.

QuestionOC<out Question thisQ, String d, QASet q, int l>           =   "[oc]"	(.
																				thisQ = handleQuestionOC(d, q);
																				// Begin Change Extension
																				namedObject = thisQ;
																				// End Change Extension
																				.)
{ DescriptionIdQuestion }
[IsAbstract<thisQ>]
[QuestionIdentifier<thisQ>]																																				
{IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerChoice<thisQ>}.

QuestionMC<out Question thisQ, String d, QASet q, int l>           =   "[mc]"	(.
																				thisQ = handleQuestionMC(d, q);
																				// Begin Change Extension
																				namedObject = thisQ;
																				// End Change Extension
																				.)
{ DescriptionIdQuestion }
[IsAbstract<thisQ>]
[QuestionIdentifier<thisQ>]																						
{IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerChoice<thisQ>}.

QuestionDate<out Question thisQ, String d, QASet q, int l>         =  "[date]"	(.
																				thisQ = handleQuestionDate(d, q);
																				// Begin Change Extension
																				namedObject = thisQ;
																				// End Change Extension
																				.)
{ DescriptionIdQuestion }
[IsAbstract<thisQ>]
[QuestionIdentifier<thisQ>]
{IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerDate<thisQ>}.

QuestionText<out Question thisQ, String d, QASet q, int l>         =  "[text]"	(.
																				thisQ = handleQuestionText(d, q);
																				// Begin Change Extension
																				namedObject = thisQ;
																				// End Change Extension
																				.)
{ DescriptionIdQuestion }
[IsAbstract<thisQ>]
[QuestionIdentifier<thisQ>]
{IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerText<thisQ>}.

QuestionYN<out Question thisQ, String d, QASet q, int l> =   ("[jn]" | "[yn]")	(.
																				thisQ = handleQuestionYN(d, q);
																				// Begin Change Extension
																				namedObject = thisQ;
																				// End Change Extension
																				.)
{ DescriptionIdQuestion }
[IsAbstract<thisQ>]
[QuestionIdentifier<thisQ>]																																				
{IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerChoice<thisQ>}.

QuestionZC<out Question thisQ, String d, QASet q, int l>           =   "[info]"	(.
																				thisQ = handleQuestionZC(d, q);
																				// Begin Change Extension
																				namedObject = thisQ;
																				// End Change Extension
																				.)																				

{ DescriptionIdQuestion }
[IsAbstract<thisQ>]
[QuestionIdentifier<thisQ>]																
{IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerYN<thisQ>}
//below changed to above
//[IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
//AnswerYN<thisQ>]
//[IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
//AnswerYN<thisQ>]
//[IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
//AnswerYN<thisQ>]
.

AnswerNum<Question q>				=   										(.
																				int countDashes = countDashes();
																				.)
Separator Dashes Comparison<out TerminalCondition c, q>
																				(.
																				conditionStack.push(c);
																				List qcl = new LinkedList();
																				List ql = new LinkedList();
																				boolean hasIndication = false;
																				.)	
{DescriptionIdAnswer}																		
{IF(properAmountOfDashes(countDashes + 1))Indication<q, qcl, ql>
																				(.
																				hasIndication = true;
																				.)
}																				(.
																				handleQContainerIndication(qcl);
																				handleQuestionIndication(ql);
																				if (!hasIndication) createMessage(t.line, t.col,
																					"parser.decisionTree.warning.answerNotImportable",
																					Message.WARNING, q.getText());
																				conditionStack.pop();
																				.)
.

AnswerChoice<Question q>			=											(.
																				int countDashes = countDashes();
																				.)
Separator Dashes Declaration													(.
																				Token answerChoiceToken = t;
																				String answerChoiceId = kbm.findNewIDForAnswerChoice((QuestionChoice)q);
																				.)
[AnswerChoiceIdentifier<out answerChoiceId>]									(.
																				TerminalCondition c  = handleAnswerChoice(q, answerChoiceToken, answerChoiceId);
																				conditionStack.push(c);
																				List qcl = new LinkedList();
																				List ql = new LinkedList();
																				.)	
{DescriptionIdAnswer}
{IF(properAmountOfDashes(countDashes + 1))Indication<q, qcl, ql>}				
																				(.
																				handleQContainerIndication(qcl);
																				handleQuestionIndication(ql);
																				conditionStack.pop();
																				.)
.

AnswerDate<Question q>				=											(.
																				int countDashes = countDashes();
																				.)
Separator Dashes Declaration													(.
																				TerminalCondition c = handleAnswerDate(q, t);
																				conditionStack.push(c);
																				.)
																				(.
																				List qcl = new LinkedList();
																				List ql = new LinkedList();
																				boolean hasIndication = false;
																				.)																				
{DescriptionIdAnswer}
{IF(properAmountOfDashes(countDashes + 1))Indication<q, qcl, ql>				(.
																				hasIndication = true;
																				.)
}																				(.
																				handleQContainerIndication(qcl);
																				handleQuestionIndication(ql);
																				if (!hasIndication) createMessage(t.line, t.col,
																					"parser.decisionTree.warning.answerNotImportable",
																					Message.WARNING, q.getText());
																				conditionStack.pop();
																				.)
.

AnswerText<Question q>					=										(.
																				int countDashes = countDashes();
																				.)
Separator Dashes Declaration													(.
																				TerminalCondition c = handleAnswerText(q, t);
																				conditionStack.push(c);
																				.)
																				(.
																				List qcl = new LinkedList();
																				List ql = new LinkedList();
																				boolean hasIndication = false;
																				.)																				
{DescriptionIdAnswer}
{IF(properAmountOfDashes(countDashes + 1))Indication<q, qcl, ql>				(.
																				hasIndication = true;
																				.)
}																				(.
																				handleQContainerIndication(qcl);
																				handleQuestionIndication(ql);
																				if (!hasIndication) createMessage(t.line, t.col,
																					"parser.decisionTree.warning.answerNotImportable",
																					Message.WARNING, q.getText());
																				conditionStack.pop();
																				.)
.																				

AnswerYN<Question q>					=										(.
																				int countDashes = countDashes();
																				.)
Separator Dashes Declaration													(.
																				Token answerChoiceToken = t;
																				String declaration = formatDeclaration(answerChoiceToken.val);
																				TerminalCondition c = null;
																				if(declaration.equalsIgnoreCase("yes") || declaration.equalsIgnoreCase("ja")){
																					c = handleAnswerYes(q);
																				} else if(declaration.equalsIgnoreCase("no") || declaration.equalsIgnoreCase("nein")) {
																					c = handleAnswerNo(q);
																				} else if(declaration.equalsIgnoreCase("unknown") || declaration.equalsIgnoreCase("unbekannt")) {
																					c = handleAnswerUnknown(q);
																				} else {
																					createMessage(t.line, t.col,
																						"parser.decisionTree.error.wrongAnswerYNValue",
																						Message.ERROR, t.val);
																				}
																				conditionStack.push(c);
																				.)
																				(.
																				List qcl = new LinkedList();
																				List ql = new LinkedList();
																				boolean hasIndication = false;
																				.)	
																																							
{DescriptionIdAnswer}
{IF(properAmountOfDashes(countDashes + 1))Indication<q, qcl, ql>				(.
																				hasIndication = true;
																				.)
}																				(.
																				handleQContainerIndication(qcl);
																				handleQuestionIndication(ql);
																				if (!hasIndication) createMessage(t.line, t.col,
																					"parser.decisionTree.warning.answerNotImportable",
																					Message.WARNING, q.getText());
																					
																				conditionStack.pop();
																				.)

.

Indication<Question qParent, List qcl, List ql> =   
(
IF(isFirstNonDeclarationToken("[", t))
Question<out Question q, qParent>												(.
																				ql.add(q);
																				.)
|
IF(isFirstNonDeclarationToken("(", t))
Diagnosis<>
|
QContainerIndication<qcl>
)
.
QContainerIndication<List qcl>    =
Separator Dashes Declaration													(.
																				handleQContainerAccumulation(t, qcl);
																				.)
.

Diagnosis<>               =									                    (.
																				int countDashes = countDashes();
																				.)
Separator Dashes Declaration													(.
																				Token declarationToken = t;
																				.)
'(' IndicationStrength															(.
																				Token indicationStrengthToken = t;
																				Diagnosis d = handleDiagnosisIndication(declarationToken, indicationStrengthToken);
																				// Begin Change Extension
																				namedObject = d; 
																				// End Change Extension
																				
																				.)
')'																				(.
																				List qcl = new LinkedList();
																				.)

{DescriptionIdDiagnosis} 
{'[' Link ']'}
{IF(properAmountOfDashes(countDashes + 1))										
QContainerIndicationByDiagnosis<qcl>
}																				(.
																				handleQContainerIndicationByDiagnosis(d, indicationStrengthToken, qcl);
																				.)

.
QContainerIndicationByDiagnosis<List qcl> = 
Separator Dashes Declaration													(.
																				handleQContainerAccumulation(t, qcl);
																				.)
.

Separator               =   SYNC newline{newline}.

Dashes                  =	dash												
{dash																			
}.

Declaration             =   declaration									
.
Unit				    = declaration
.

Comparison<out TerminalCondition c, Question q> =								(.
																				c = null;
																				.)
(															
'<'
number																			(.
																				handleComparison(q, t);
																				double answerValue = Double.parseDouble(t.val.replaceAll("," , "."));
																				c = new CondNumLess((QuestionNum)q, answerValue);
																				.)																				
| "<="
number																			(.
																				handleComparison(q, t);
																				double answerValue = Double.parseDouble(t.val.replaceAll("," , "."));
																				c = new CondNumLessEqual((QuestionNum)q, answerValue);																			
																				.)
| '>'
number																			(.
																				handleComparison(q, t);
																				double answerValue = Double.parseDouble(t.val.replaceAll("," , "."));
																				c = new CondNumGreater((QuestionNum)q, answerValue);																				
																				.)
| ">="
number																			(.
																				handleComparison(q, t);
																				double answerValue = Double.parseDouble(t.val.replaceAll("," , "."));
																				c = new CondNumGreaterEqual((QuestionNum)q, answerValue);																				
																				.)
| '='
number																			(.
																				handleComparison(q, t);
																				double answerValue = Double.parseDouble(t.val.replaceAll("," , "."));
																				c = new CondNumEqual((QuestionNum)q, answerValue);																				
																				.)
| 
bracketOpen
number																			(.
																				Token l = t;
																				.)
number																			(.
																				Token r = t;
																				handleComparison(q, l, r);
																				double intervalLeft = Double.parseDouble(l.val.replaceAll("," , "."));
																				double intervalRight = Double.parseDouble(r.val.replaceAll("," , "."));																				
																				c = new CondNumIn((QuestionNum)q, intervalLeft, intervalRight);																				
																				.)
bracketClose																				
)
.

IndicationStrength  =
"N1" | "N2" | "N3" | "N4" | "N5" | "N5+"										(.
																				t.val = "N5x";
																				.)
| "N6" | "N7"
| "P1" | "P2" | "P3" | "P4" | "P5" | "P5+"										(.
																				t.val = "P5x";
																				.)
| "P6" | "P7"
| '+'																			(.
																				t.val = "P1";
																				.)
| "++"																			(.
																				t.val = "P4";
																				.)
| "+++"																			(.
																				t.val = "P7";
																				.)
// Begin Change Extension
| "!"																			(.
																				t.val = "P7";
																				.)		
| "?"																			(.
																				t.val = "P3";
																				.)	
// End Change Extension

// Hotfix enabling SI-setValues
| number
// End HotFix

// Hotfix for choice SI
| Declaration
//
																																																									
| dash																			(.
																				t.val = "N1";
																				.)
[dash																			(.
																				t.val = "N4";
																				.)
[dash																			(.
																				t.val = "N7";
																				.)
]] 
.

IsAbstract<Question q> = ("<abstrakt>" | "<abstract>")							(.													
																				handleQuestionAbstract(q);
																				.)
.																				
QuestionIdentifier<Question q> = ID												(.
																				handleQuestionIdentifier(q, t.val);
																				.)
.
AnswerChoiceIdentifier<out String answerChoiceId> = ID
																				(.
																				answerChoiceId = handleAnswerChoiceIdentifier(t.val);
																				.)
.


				
//		
// Begin Change Extension		
//																												
DescriptionIdAnswer =  descriptionId 											(.
																				String id = t.val.trim();
																				abbr.add(id);
																				ArrayList al = mapAnswers.get(id);
																				if(al == null){
																					al = new ArrayList(); 
																				}
																				al.add(answer);
																				mapAnswers.put(id,al);
																				.)																		
.
DescriptionIdDiagnosis =  descriptionId 										(.
																				String id = t.val.trim(); 
																				abbr.add(id);
																				ArrayList al = mapNamedObjects.get(id);
																				if(al == null){
																					al = new ArrayList();
																				}
																				al.add(namedObject);
																				mapNamedObjects.put(id,al);
																				.)
.
DescriptionIdQuestion =  descriptionId 											(.
																				String id = t.val.trim();
																				abbr.add(id);
																				ArrayList al = mapNamedObjects.get(id);
																				if(al == null){
																					al = new ArrayList();
																				}
																				al.add(namedObject);
																				mapNamedObjects.put(id,al);
																				.)
.
Description = DescriptionID             										(. 
																				 String id = ""; 
																				 String typ = "info"; 
																				 String name = ""; 
																				 content = ""; 
																				 id = t.val.trim();
																				.)
'|'
{Typ 																		    (.
																				typ = t.val.trim();
																				typ = typ.toLowerCase(); 
																				.)
}																				
'|' {Name															        	(.
																				name = t.val.trim();
																				.)
}																				
'|' {Content}							            				            (.
																				boolean flag = false; 
																				if(name.startsWith("\"") && name.endsWith("\"")){
																					name = name.replaceAll("\"","");
																					flag = true; 
																				}
																				if(!allowedNames.contains(name) && !flag && !allowedNames.isEmpty()){																				
																					 createMessage(t.line, t.col,
																					"parser.decisionTree.warning.nameNotAllowed",
																					Message.WARNING, "Bezeichner nicht erlaubt");																				
																				}
																				if(mapNamedObjects.containsKey(id) && mapNamedObjects.get(id)!= null){
																					for(Object namedObject : mapNamedObjects.get(id)){
																						if(namedObject instanceof NamedObject){
																							name = change(name);
																							addMMInfo((NamedObject)namedObject,name,typ,content);	
																						}
																					}																			
																				}
																				else if(mapAnswers.containsKey(id) && mapAnswers.get(id) !=null) {
																					for(Object answer : mapAnswers.get(id)){
																					 	if(answer instanceof AnswerChoice){
																							AnswerChoice a = (AnswerChoice)answer;
																							setAnswerContent(a,content);
																						}
																					}
																				}
																				.)																				
.
DescriptionID =  descriptionId												
.
Typ  =   declaration
.
Name = declaration 								     			    
.
Content = (('-' | '=' | newline | '<' | '>' | '{' | '}' | '[' | ']' 
| '(' | ')' | '#' | '@' | '\'' | '\\' | '\"' ) | descriptionId 
| ID	| declaration | '/' | number)   										(.
																					content = content.concat(t.val); 
																				.)
.
// 
// Anfang LINK
//
Link ='[' declaration  															(.
																				String url = t.val;
																				String typ = "url";
																				String decl = ""; 
																				.)
{ '=' declaration																(.
																				url = url.concat("=" + t.val);
																				.)
}																				
']'
{ '['
declaration																		(.
																				decl = t.val; 
																				decl = change(decl);
																				.)
']' }																			(.
																				if(!savedLinks.contains(namedObject)){
																					savedLinks.add(namedObject);
																				}
																				addMMInfo(namedObject,decl,typ,url); 
																				.)																					
.

//
// AllowedNames
//
AllowedNames = allowedNames
'=' '{'
{ declaration        															    (.
																					String value = t.val.trim();
																					String[] values = value.split(",");
																					for(String valueTemp : values){
																						valueTemp = valueTemp.trim(); 
																						if(!valueTemp.equals(",")){
																					 		valueTemp = valueTemp.replaceAll("\"","");
																					 		if(valueTemp.equals("-")){ 
																					 			allowedNames.add("");
																					 		}
																					 		else{
																					 			allowedNames.add(valueTemp);
																					 		}
																					 	}
																					}
																				.)
}																				(.
																				if(!savedLinks.isEmpty()){
																					Iterator iter = savedLinks.iterator(); 
																					while(iter.hasNext()){
																						NamedObject link = (NamedObject)iter.next();
																						MMInfoStorage mmis = (MMInfoStorage)link.getProperties().getProperty(Property.MMINFO);
																						Iterator itermarkups = mmis.getAllDCMarkups().iterator(); 
																						while(itermarkups.hasNext()){
																							DCMarkup dcmarkup = (DCMarkup)itermarkups.next(); 
																								String title = dcmarkup.getContent(DCElement.TITLE); 
																								boolean flag = false; 
																								if(title.startsWith("\"") && title.endsWith("\"")){
																									title = title.replaceAll("\"","");
																									flag = true; 
																								}
																								title = revChange(title);
																								if(allowedNames.contains(title) || flag || allowedNames.isEmpty()){
																								}
																								else{
																					 				createMessage(0, 0,
																									"parser.decisionTree.warning.nameNotAllowed",
																									Message.WARNING, "Bezeichner nicht erlaubt");																								
																								//Iterator iterer = mmis.getMMInfo(dcmarkup).iterator();
																								//while(iterer.hasNext()){
																								//	MMInfoObject mmio = (MMInfoObject)iterer.next(); 
																								//	mmis.removeMMInfo(mmio);
																								}
																									 
																								}
																						}
																					
																				}
																				.)
'}' newline																				
.																				
//
//End Change
//
END DecisionTree.
