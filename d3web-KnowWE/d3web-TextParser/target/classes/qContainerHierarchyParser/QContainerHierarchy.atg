import java.util.*;
import java.text.MessageFormat;
import de.d3web.kernel.domainModel.*;
import de.d3web.kernel.domainModel.qasets.*;
import de.d3web.textParser.Utils.Message;

/**
 * Dieser Parser verwendet zum abspeichern bereits eingelesener Diagnosen eine Map, anstatt die Diagnosen direkt in den EBNF-Produktionen
 * zu übergeben. Dies könnte man noch verbessern.
 * Außerdem könnte man die TOKENS so abändern, daß man Spaces per default ignoriert.
 * @author Franz Schwab
 */

COMPILER QContainerHierarchy

	/**
	 * speichert zu jedem Level (Tiefe des Baumes bzw. Anzahl der Anführungszeichen) die zuletzt eingelesene Frageklasse
	 */
	private Map<Integer, QContainer> ht = new Hashtable<Integer, QContainer>();
	/**
	 * die aktuelle Tiefe des Baumes (Anzahl der Anführungszeichen)
	 */
	private int levelPeak = -1;
	/**
	 * der Token ds letzten gelesenen Dashes
	 */
	private Token lastDashToken;
	private KnowledgeBase kb;
	private KnowledgeBaseManagement kbm;
	/**
	 * Update-Modus.
	 * true: hierbei können nur Eintrage hinzugefügt werden
	 * false: Einträge können überschrieben werden (ist nur bei einer leeren KB von Bedeutung) 
	 */
	private boolean addMode;
	/**
	 * Anzahl der hinzugefügten Frageklassen (alle)
	 */
	private int numberOfInserts = 0;
    /**
     * Anzahl der hinzugefügten Linked-Unter-Frageklassen
     */
    private int numberOfInsertsAsLinkedChild = 0;
    /**
     * Anzahl der hinzugefügten Unter-Diagnosen
     */
    private int numberOfInsertsAsChild = 0;
    /**
     * Toplevel-Modus, wird angewendet bei einem Update, um Frageklassen auf Level 0 hinzuzufügen
     */
    private boolean toplevelMode = false;
    /**
     * Gibt an, ob die Frageklassen, mit der der Fragebogen gestartet wird, angegeben wurden oder nicht
     */
    private boolean setStartQContainers = false;
    /**
     * dient zur Speicherung der Start-Frageklassen
     */
    private TreeMap<Integer, QContainer> startQContainerTreeMap = new TreeMap<Integer, QContainer>();
    /**
     * aktuelle Frageklasse
     */
    private QContainer currentQContainer = null;
    /**
     * Resource-Bundle welches zum Parsen von Meldungen benötigt wird
     */
    private static final ResourceBundle rb = ResourceBundle.getBundle("properties.textParser");
	/**
	 * Überprüft die Zulässigkeit des Levels, auf dem die Frageklasse eingefügt werden soll.
	 * @param level das level der einzutragenden Frageklasse
	 * @param qContainerValue value der einzutragenden Frageklasse
	 * @return true: level erlaubt, false: level falsch gewählt, Fehlermeldung wird geworfen
	 */
	private boolean checkAndSetAllowedLevel(int level, String qContainerValue) {
		boolean returnValue = true;
		if (level > levelPeak+1) {
			int levelDifference = level - (levelPeak+1);
			createMessage(
                    lastDashToken.line, lastDashToken.col, "parser.qContainerHierarchy.error.level",
                    Message.ERROR, qContainerValue, levelDifference);
			returnValue = false;
		} else {
			levelPeak = level;
		}
		return returnValue;
	}
    
    /**
     * Erstellt eine Meldung.
     * @param row Zeile in der Eingabe-Datei
     * @param column Spalte  in der Eingabe-Datei
     * @param key Schlüssel der Meldung
     * @param messageType Message.ERROR, Message.WARNING oder MESSAGE.Note
     * @param values Parameter, welche in den Text der Meldung mit aufgenommen werden sollen
     */
    private void createMessage(
            int row, int column, String key, String messageType, Object ... values) {
        String result = rb.getString("parser.error.unknownError") + ": "+key;
        try {
            result = MessageFormat.format(
                rb.getString(key), values);
        }
        catch (MissingResourceException e) {}
        errors.Error(row, column, result, messageType);        
    }
	/**
	 * Überprüft, ob linkedParent ein Vorgäner von possibleChild ist.
	 * @param linkedParent Vorgänger
	 * @param possibleChild mögliches Kind
	 * @return true: linkedParent ist Vorgänger, false: linkedParent ist nicht Vorgänger
	 */
	private boolean isAncestor(QContainer linkedParent, QContainer possibleChild) {
        boolean isAncestor = false;        
        if(linkedParent != null && linkedParent == possibleChild) return true;
        else {
            List<QContainer> ancestors = linkedParent.getParents();
            for(QContainer nextParent: ancestors) {
                isAncestor = isAncestor(nextParent, possibleChild);
                if(isAncestor) return isAncestor;
            }
        }
        return false;
    }
    
    /**
     * Liefert die Meldung für erfolgreiches Parsen
     * @return Message für erfolgreiches Parsen
     */
    public Message getSuccessNote() {
        Object[] values = {numberOfInserts,
                (numberOfInserts - (numberOfInsertsAsChild + numberOfInsertsAsLinkedChild)),
                numberOfInsertsAsChild, numberOfInsertsAsLinkedChild, addMode};
        String result = rb.getString("parser.error.unknownError");
        try {
            result = MessageFormat.format(
                rb.getString("parser.qContainerHierarchy.success"), values);
        }
        catch (MissingResourceException e) {}
        return new Message(Message.NOTE, result, "", 0,0,"");
    }
    
    /**
     * Meldung, die Informationen über die Start-Frageklassen enthält
     * @return die Meldung
     */
    public Message getInitNotes() {
        String result = null;
        Object[] values = null;
        if(addMode && setStartQContainers)
            result = MessageFormat.format(rb.getString("parser.qContainerHierarchy.newStartQContainers"), values);
        
        if(addMode && !setStartQContainers) 
            result = MessageFormat.format(rb.getString("parser.qContainerHierarchy.oldStartQContainers"), values);
        
        return new Message(Message.NOTE, result, "", 0,0,"");
    }
	
	
CHARACTERS
space = ' '.
allowedDeclaration = ANY - '-' - '\n' - '\r' - '\"' - '[' - ']' - '#' - space.
allowedDeclarationFurther = allowedDeclaration + '-' + space.
allowedDeclarationFurtherWithBrackets = allowedDeclarationFurther + '[' + ']' + '#'.
commentChar = ANY - '\n' - '\r'.
digit = "0123456789".

TOKENS
// die Bezeichnung darf keinen Zeilenumbruch, sowie keine Anführungszeichen enthalten
// Anführungsstriche sind am Anfang nur erlaubt, wenn die Bezeichnung in Anführungsstrichen steht
Declaration = (allowedDeclaration {allowedDeclarationFurther}) | '\"' {allowedDeclarationFurtherWithBrackets} '\"'.
ID = '#'allowedDeclaration{allowedDeclaration}.
StartQContainerNumberInBrackets = '['digit{digit}']'.

// die Praxis hat gezeigt, daß man Kommentare besser als Pragmas behandelt.
PRAGMAS
comment = "//"{commentChar}('\n'|'\r'){('\n'|'\r')}.


// COMMENTS FROM "/*" TO "*/" NESTED
// COMMENTS FROM "//" TO '\r' '\n'

// Spaces werden per default ignoriert, also müsste man dies aus- bzw. einkommentieren
// (siehe Änderung in den Frame-Dateien)
IGNORE '\t' + ' '

PRODUCTIONS
QContainerHierarchy =											(.
																QContainer rootQContainer = (QContainer)kb.getRootQASet();
																ht.put(-1, rootQContainer);
																.)
{('\n'|'\r')}
QContainer						 								(.
																.)
{
QContainer														(.
								   								.)
}																(.
																.)
.
QContainer =													(.
																int qContainerLevel = 0;
																.)
{"-"															(.
																qContainerLevel = qContainerLevel + 1;
																.)
}																(.
																lastDashToken = t;
																.)
Declaration														(.
																String qContainerValue = t.val;
																qContainerValue = qContainerValue.trim();
																if (qContainerValue.charAt(0) == '\"'
																		&& qContainerValue.charAt(qContainerValue.length() - 1) == '\"') {
																	qContainerValue = qContainerValue.substring(1, qContainerValue.length() - 1);
																}
														
																// semantisches Parsing der Zeile!
																if (addMode == true && qContainerLevel == 0) {
																	if (qContainerValue.equals(rb
																			.getString("parser.qContainerHierarchy.toplevel"))) {
																		ht.put(0, (QContainer)kb.getRootQASet());
																		toplevelMode = true;
																	} else {
																		toplevelMode = false;
																		QContainer anchorQContainer = kbm.findQContainer(qContainerValue);
																		currentQContainer = anchorQContainer;
																		if (anchorQContainer != null) {
																			ht.put(qContainerLevel, anchorQContainer);
																		} else {
																			createMessage(t.line, t.col,
																					"parser.qContainerHierarchy.error.anchor",
																					Message.ERROR, qContainerValue);
																		}
																	}
																}
																if (checkAndSetAllowedLevel(qContainerLevel, qContainerValue)
																		&& (qContainerLevel != 0 || addMode == false)) {
																	QContainer ancestor = ht.get(qContainerLevel - 1);
																	QContainer stillContainedQContainer = kbm
																			.findQContainer(qContainerValue);
																	currentQContainer = stillContainedQContainer;
																	if (stillContainedQContainer == null) {
																		QContainer child = kbm.createQContainer(qContainerValue, ancestor);
																		currentQContainer = child;
																		ht.put(qContainerLevel, child);
																		numberOfInserts++;
																		// direkte Toplevel-Kinder bei update nicht mitrechnen bei
																		// numberOfInsertsAsChild, denn sie sind ja eigentlich Toplevel-QContainer
																		if (((qContainerLevel > 1) && toplevelMode)
																				|| ((qContainerLevel > 0) && !toplevelMode))
																			numberOfInsertsAsChild++;
																	} else if (!isAncestor(ancestor, stillContainedQContainer)) {
																		if (!stillContainedQContainer.getParents().contains(ancestor)) {
																			stillContainedQContainer.addLinkedParent(ancestor);
																			numberOfInserts++;
																			numberOfInsertsAsLinkedChild++;
																		} else {
																			createMessage(t.line, t.col, "parser.qContainerHierarchy.error.doubleInsertion", Message.ERROR, qContainerValue);
																		}
																		ht.put(qContainerLevel, stillContainedQContainer);
																	} else {
																		createMessage(t.line, t.col,
																				"parser.qContainerHierarchy.error.loop", Message.ERROR, qContainerValue);
																	}
																}
																.)
[
StartQContainerNumberInBrackets 								(.
																int startQContainerPosition = -1;
																String tValueWithoutBrackets = t.val.substring(1, t.val.length()-1);
																try {
																	startQContainerPosition = Integer.valueOf(tValueWithoutBrackets);
																} catch(NumberFormatException e) {
																	// COCO: falsches format
																	createMessage(t.line, t.col,
																				"parser.qContainerHierarchy.error.numberFormatException", Message.ERROR, qContainerValue, tValueWithoutBrackets);
																	
																}
																setStartQContainers = true;
																if (!startQContainerTreeMap.containsKey(startQContainerPosition)) {
																	startQContainerTreeMap.put(startQContainerPosition, currentQContainer);
																} else if (currentQContainer != startQContainerTreeMap.get(startQContainerPosition)) {
																	String alreadyContainedQContainer = startQContainerTreeMap.get(startQContainerPosition).toString();
																	createMessage(t.line, t.col, "parser.qContainerHierarchy.error.multipleQCStartPosition", Message.ERROR, qContainerValue, alreadyContainedQContainer, tValueWithoutBrackets);
																} else {
																	createMessage(t.line, t.col, "parser.qContainerHierarchy.error.sameQCStartPosition", Message.ERROR, qContainerValue, tValueWithoutBrackets);
																}
																
																
																.)
]
[
ID																(.
																String id = t.val.substring(1, t.val.length());
																id = id.trim();
																QContainer qcSearch = kbm.findQContainer(id);
																if (qcSearch == null) {
																	currentQContainer.setId(id);
																	//THIS IS A HOTFIX
																	// since the objects are held in a SORTED List (by ID)
																	// one may not change the ID afterwards
																	// this hotfix creates and removes a dummy object
																	// to force a sort
																	QContainer dummy = kbm.createQContainer("dummy", kbm.getKnowledgeBase().getRootQASet());
				
																	try {
																	kbm.getKnowledgeBase().remove(dummy);
																	kbm.getKnowledgeBase().getRootQASet().removeChild(dummy);
																	} catch (IllegalAccessException e) {
																		// TODO Auto-generated catch block
																		e.printStackTrace();
																	}
																	//END HOTFIX
																} else if (qcSearch != currentQContainer) {
																	createMessage(t.line, t.col, "parser.qContainerHierarchy.error.idAlreadyExists", Message.ERROR, currentQContainer.getText(), id);
																}
																.)
]

SYNC																														
(('\n'|'\r'){('\n'|'\r')}
| EOF)															(.
																if (setStartQContainers) {
																	Iterator<QContainer> iterator = (startQContainerTreeMap).values().iterator();
																	List<QContainer> startQContainerList = new LinkedList<QContainer>();
																	while(iterator.hasNext()) startQContainerList.add(iterator.next());
																	kb.setInitQuestions(startQContainerList);
																}
																.)				
.


END QContainerHierarchy.