import java.util.*;
import java.text.*;
import de.d3web.kernel.domainModel.*;
import de.d3web.kernel.domainModel.qasets.*;
import de.d3web.textParser.Utils.Message;
import de.d3web.kernel.supportknowledge.*;
import de.d3web.kernel.domainModel.ruleCondition.*;
import de.d3web.kernel.domainModel.answers.*;
import de.d3web.textParser.Utils.*;
import de.d3web.textParser.decisionTable.DecisionTableParserManagement;
import de.d3web.textParser.decisionTable.MessageGenerator;
import de.d3web.kernel.psMethods.*;
import de.d3web.kernel.psMethods.heuristic.*;
import de.d3web.kernel.psMethods.nextQASet.*;

/**
 * Im Gegensatz zum QContainerHierarchy-Parser und zum DiagnosisHierarchy-Parser wird hier keine Map mehr benutzt,
 * um die zuletzt eingelesenen, relevanten Zeilen-Elemente zu speichern.
 * In diesem Parser wurde vielmehr die Möglichkeit von Coco ausgenutzt, in den EBNF-Produktionen Eingabe- sowie
 * Ausgabeparameter zu gebrauchen.
 * Weiterhin wurde die Token-Struktur verbessert, der Parser ignoriert nun wieder per default Spaces,
 * dies hat den Vorteil, das darauf nicht mehr geachtet werden muss, bzw. den Spaces nun keine syntaktische Funktion abverlangt wird.
 * Im Zuge einer Verbesserung der beiden anderen, oben genannten Parser könnte man die hier verwendete Struktur dort auch umsetzen.
 * 
 * @author Franz Schwab
 */

COMPILER DecisionTree

	
	private KnowledgeBase kb;
	private KnowledgeBaseManagement kbm;
	private boolean addMode;
	
	private int numberOfInsertedQuestions = 0;
	private int numberOfInsertedFollowingQuestions = 0;
    private int numberOfInsertedQContainerIndications = 0;
	private int numberOfInsertedDiagnosisDerivations = 0;
	private int numberOfInsertedQContainerIndicationsByDiagnosis = 0;
	
	public List<Message> successMessages = new LinkedList<Message>();
	
    private static final ResourceBundle rb = ResourceBundle.getBundle("properties.textParser");
    
    /**
     * Setzt die Zähler für die geparsten Elemente zurück
     */
    private void resetNumberCounter() {
	    this.numberOfInsertedQuestions = 0;
	    this.numberOfInsertedFollowingQuestions = 0;
		this.numberOfInsertedQContainerIndications = 0;
		this.numberOfInsertedDiagnosisDerivations = 0;
		this.numberOfInsertedQContainerIndicationsByDiagnosis = 0;
	}
	
    /**
     * Erstellt eine Meldung.
     * @param row Zeile in der Eingabe-Datei
     * @param column Spalte  in der Eingabe-Datei
     * @param key Schlüssel der Meldung
     * @param messageType Message.ERROR, Message.WARNING oder MESSAGE.Note
     * @param values Parameter, welche in den Text der Meldung mit aufgenommen werden sollen
     */
    private void createMessage(
            int row, int column, String key, String messageType, Object ... values) {
        String result = rb.getString("parser.error.unknownError") + ": "+key;
        try {
            result = MessageFormat.format(
                rb.getString(key), values);
        }
        catch (MissingResourceException e) {}
        
        String globalErrorKey = null;
        String objectName = null;
        if(key.equals(KEY_DIAGNOSIS_NOT_FOUND)) {
        	globalErrorKey = MessageGenerator.KEY_INVALID_DIAGNOSIS;
        	objectName = (String)values[0];
        }
        errors.Error(row, column, result, messageType,globalErrorKey, objectName );        
    
    }
	
    /**
     * Fügt eine Erfolgsmeldung zur Liste hinzu (pro Frageklasse)
     * @param qContainer Name der Frageklasse
     */
    public void addSuccessNote(String qContainer) {
        Object[] values = {
        	qContainer,
		    this.numberOfInsertedQuestions,
		    this.numberOfInsertedFollowingQuestions,
			this.numberOfInsertedQContainerIndications,
			this.numberOfInsertedDiagnosisDerivations,
			this.numberOfInsertedQContainerIndicationsByDiagnosis
    	};
        String result = rb.getString("parser.error.unknownError");
        try {
            result = MessageFormat.format(
                rb.getString("parser.decisionTree.success"), values);
        }
        catch (MissingResourceException e) {}
        successMessages.add(new Message(Message.NOTE, result, "", 0,0,""));
        
        resetNumberCounter();
    }
    
    /**
     * Formatiert den Bezeichner einer Frageklasse, entfernen von Whitespace am Anfang und Ende sowie der Anführungszeichen
     * @param decl unformatierter Name der Frageklasse
     * @return formatierter Name der Frageklasse
     */
    private String formatDeclaration(String decl) {
        // fehler besser abfangen: java.lang.StringIndexOutOfBoundsException: String index out of range: 0
		decl = decl.trim();
		try {
			if (decl.charAt(0) == '\"'
					&& decl.charAt(decl.length() - 1) == '\"') {
				decl = decl.substring(1, decl.length() - 1);
			}
		} catch(StringIndexOutOfBoundsException e) {
			createMessage(t.line, t.col,
					"parser.decisionTree.error.formatDeclaration",
					Message.ERROR);
		}
		return decl;
	}
    
    /**
     * Überprüft, ob das Ende der zu parsenden Datei erreicht ist
     * @return true: Ende ist nicht erreicht, false: Ende ist erreicht
     */
    private boolean isNotEOF() {
		scanner.ResetPeek();
    	Token x = la;
    	while (x.kind == _newline) {
    		x = scanner.Peek();
    	}
    	return x.kind != _EOF;
    }
    
    /**
     * Überprüft, ob in der nächsten Zeile eine Frage der Ebene 1 (1 Dash) steht, also direkt in einer Frageklasse enthalten ist.
     * @return true: ist Frage der ersten Ebene, false: ist nicht Frage der ersten Ebene
     */
    private boolean isFirstLevelQuestion() {
		scanner.ResetPeek();
    	Token x = la;
    	while (x.kind == _newline) {
    		x = scanner.Peek();
    	}
    	return x.kind == _dash && scanner.Peek().kind != _dash;
    }
    
    
    /**
     * Überprüft, ob die nächste Zeile eine bestimmte Anzahl an Anführungsstrichen vorweisen kann.
     * @param dashes Anzahl der Dashes, auf die in der nächsten Zeile überprüft werden soll
     * @return true: geforderte Anzahl liegt vor, false: geforderte Anzahl liegt nicht vor.
     */
    private boolean properAmountOfDashes(int dashes) {
		scanner.ResetPeek();
    	int thisDashes = 0;
    	Token x = la;
    	while (x.kind == _newline) {
			x = scanner.Peek();
		}
    	while (x.kind == _dash) {
    		x = scanner.Peek();
    		thisDashes++;
    	}
    	return thisDashes == dashes;
    }
    
    
    /**
     * zählt die Anführungsstriche der nächsten Zeile
     * @return Anzahl der Anführungsstriche der nächsten Zeile
     */
    private int countDashes() {
		scanner.ResetPeek();
    	int countDashes = 0;
    	Token x = la;
		while (x.kind == _newline) {
			x = scanner.Peek();
		}
		while (x.kind == _dash) {
			x = scanner.Peek();
			countDashes++;
		}
		return countDashes;
	}
	
	/**
	 * Überprüft, ob der String c der Anfang des Tokens ist, der nach dem gerade betrachteten Declaration-Tokens kommt.
	 * Es geht darum zu überprüfen, ob in der gleichen Zeile der Declaration noch ein Token kommt, der z.B. auf einen Fragetyp hinweist. 
	 * @param c der zu suchende String
	 * @param t der aktuelle Token
	 * @return true: der String c wurde als Anfang des nächsten Tokens gefunden, ansonsten false
	 */
	private boolean isFirstNonDeclarationToken(String c, Token t) {
		scanner.ResetPeek();
		while (t.kind != _dash) {
			t = scanner.Peek();
		}
		while (t.kind == _dash) {
			t = scanner.Peek();
		}
		Token sp = scanner.Peek();
		boolean result = (t.kind==_declaration && sp.val.startsWith(c));
		return result;
	}
	
	/**
	 * "handle"-Methoden sind ausgelagerte Methoden, um die syntaktische EBNF im *.atg-File klarer von den semantischen Aktionen zu trennen.
	 * Dies ist eine Handle-Methode für die semantische Behandlung einer Frageklassen-Definition.
	 * Bei allen folgenden handle-Methoden weist die Bezeichnung darauf hin, wo sie in der Syntax eingesetzt wird.
	 * Es werden nur noch Parameter und return-Typen angegeben.
	 * @param q Token des aktuellen, zu suchenden QContainers
	 * @return der QContainer
	 */
	private QContainer handleQContainerDefinition(Token q) {
		resetNumberCounter();
		QContainer qc = null;
		String declaration = q.val.trim();
		declaration = formatDeclaration(q.val);
		qc = kbm.findQContainer(declaration);
		if (qc == null) {
			createMessage(q.line, q.col,
			"parser.decisionTree.error.qContainerNotFound",
			Message.ERROR, declaration);
		}
		if (addMode && (qc.getChildren().size() > 0)) {
			createMessage(q.line, q.col,
			"parser.decisionTree.error.update.qContainerNotEmpty",
			Message.ERROR, declaration);
		}
		return qc;
	}
	
	/**
	 * @param q abstrakte Frage
	 */
	private void handleQuestionAbstract(Question q) {
		q.getProperties().setProperty(Property.ABSTRACTION_QUESTION, true);
	}
	
	/**
	 * @param intervalLeft linke Intervall-Grenze, eingeschlossen
	 * @param intervalRight rechte Intervall-Grenze, eingeschlossen
	 * @param d Name der numerischen Frage
	 * @param unit Einheit des Antworten-Bereichs
	 * @param q Vater-QASet
	 * @return die Frage, die erzeugt wurde
	 */
	private Question handleQuestionNum(Double intervalLeft, Double intervalRight, String d, String unit, QASet q) {
		QuestionNum currentQuestion = kbm.createQuestionNum(d, q);               
        if (unit != null) currentQuestion.getProperties().setProperty(Property.UNIT, unit);
        if (intervalLeft != null && intervalRight != null) {
	        NumericalInterval range = new NumericalInterval(intervalLeft, intervalRight);
			currentQuestion.getProperties().setProperty(Property.QUESTION_NUM_RANGE, range);
		}
		this.numberOfInsertedQuestions++;
        return currentQuestion;
	}
	
	/**
	 * @param d Name der OC-Frage
	 * @param q Vater-QASet
	 * @return die erzeugte Frage
	 */
	private Question handleQuestionOC(String d, QASet q) {
		Question currentQuestion = kbm.createQuestionOC(d, q, new AnswerChoice[] {});
		this.numberOfInsertedQuestions++;
		return currentQuestion;
	}
	
	/**
	 * @param d Declaration der MC-Frage
	 * @param q Vater-QASet
	 * @return erzeugte Frage
	 */
	private Question handleQuestionMC(String d, QASet q) {
		Question currentQuestion = kbm.createQuestionMC(d, q, new AnswerChoice[] {});
		this.numberOfInsertedQuestions++;
		return currentQuestion;
	}
	
	/**
	 * wird wohl erstmal nicht gebraucht, die gesamte QuestionDate-Behandlung wird auch von knowme noch nicht unterstützt
	 * @param d Declaration der Date-Frage
	 * @param q Vater-QASet
	 * @return erzeugte Frage
	 */
	private Question handleQuestionDate(String d, QASet q) {
		Question currentQuestion = kbm.createQuestionDate(d, q);
		this.numberOfInsertedQuestions++;
		return currentQuestion;
	}
	
	/**
	 * @param d Declaration der Text-Frage
	 * @param q Vater-QASet
	 * @return erzeugte Frage
	 */
	private Question handleQuestionText(String d, QASet q) {
		Question currentQuestion = kbm.createQuestionText(d, q);
		this.numberOfInsertedQuestions++;
		return currentQuestion;
	}
	
	/**
	 * @param d Declaration der YN-Frage
	 * @param q Vater-QASet
	 * @return erzeugte Frage
	 */
	private Question handleQuestionYN(String d, QASet q) {
		Question currentQuestion = kbm.createQuestionYN(d, q);
		this.numberOfInsertedQuestions++;
		return currentQuestion;
	}
	
	/**
	 * handled für AnswerNum den Comparator; anstatt möglicher Methode "handleAnswerNum()".
	 * Behandelt Vergleiche mit nur einem numerischen Wert als Antwort
	 * @param q die Frage, für die der Vergleich durchgeführt werden soll
	 * @param doubleValue der Wert, mit dem verglichen werden soll
	 */
	private void handleComparison(Question q, Token doubleValue) {
		NumericalInterval range = (NumericalInterval) q.getProperties().getProperty(Property.QUESTION_NUM_RANGE);
		double answerValue = Double.parseDouble(doubleValue.val.replaceAll("," , "."));
	    if(range != null && !range.contains(answerValue))
	        createMessage(t.line, t.col,
			"parser.decisionTree.error.notMatchingInterval1",
			Message.ERROR, answerValue);
	}
	
	/**
	 * handled für AnswerNum den Comparator; anstatt möglicher Methode "handleAnswerNum()".
	 * Behandelt Vergleiche mit zwei numerischen Werten als Antwort-Berich (Intervall)
	 * @param q die Frage, für die der Vergleich durchgeführt werden soll
	 * @param doubleValueLeft linke Grenze, mit der verglichen werden soll
	 * @param doubleValueRight rechte Grenze, mit der verglichen werden soll
	 */
	private void handleComparison(Question q, Token doubleValueLeft, Token doubleValueRight) {
		NumericalInterval range = (NumericalInterval) q.getProperties().getProperty(Property.QUESTION_NUM_RANGE);
		double answerValueLeft = Double.parseDouble(doubleValueLeft.val.replaceAll("," , "."));
		double answerValueRight = Double.parseDouble(doubleValueRight.val.replaceAll("," , "."));
	    if(range != null && !(range.contains(answerValueLeft)&&range.contains(answerValueRight)))
	        createMessage(t.line, t.col,
			"parser.decisionTree.error.notMatchingInterval2",
			Message.ERROR, answerValueLeft, answerValueRight);
	}
	
	/**
	 * @param q Frage
	 * @param t Token der AnswerChoice
	 * @return AbstractCondition, welche in die KB eingefügt wurde. null, wenn ein Fehler auftrat.
	 */
	private AbstractCondition handleAnswerChoice(Question q, Token t, String id) {
		AnswerChoice acSearch = kbm.findAnswerChoice((QuestionChoice)q, id);
		if (acSearch == null) {
			String declaration = formatDeclaration(t.val);
			AnswerChoice answerChoice = AnswerFactory.createAnswerChoice(id, declaration);
			answerChoice.setQuestion(q);
			QuestionChoice qc = (QuestionChoice)q;
			qc.addAlternative(answerChoice);
			CondEqual c = new CondEqual((QuestionChoice)q, answerChoice);
			return c;
		} else {
			createMessage(t.line, t.col, "parser.decisionTree.error.ChoiceAnswerIdAlreadyExists", Message.ERROR, q.getText(), id);
			return null;
		}
	}
	
	/**
	 * wird wohl erstmal nicht gebraucht, die gesamte QuestionDate-Behandlung wird auch von knowme noch nicht unterstützt
	 * @param q Frage
	 * @param t Token der AnswerDate
	 * @return AbstractCondition, welche in die KB eingefügt wurde
	 */
	private AbstractCondition handleAnswerDate(Question q, Token t) {
//		String declaration = formatDeclaration(t.val);
//		AnswerDate answerDate = new AnswerDate();
//		//COCO: todo!
//		//TODO: todo!
//		DateFormat d = new SimpleDateFormat();
//		answerDate.setValue(d.parse(declaration));
//		answerDate.setQuestion(q);
//		// diese Methode gibts noch nicht
//		CondEqual c = new CondEqual(q, answerDate);
		return null;
	}
	
	/**
	 * @param q Frage
	 * @param t Token der AnswerText
	 * @return AbstractCondition, welche in die KB eingefügt wurde
	 */
	private AbstractCondition handleAnswerText(Question q, Token t) {
		String declaration = formatDeclaration(t.val);
		AnswerText answerText = new AnswerText();
		answerText.setText(declaration);
		answerText.setQuestion(q);
		CondTextEqual c = new CondTextEqual((QuestionText)q, declaration);
		return c;
	}
	
	/**
	 * @param q Frage
	 * @param declaration Declaration der AnswerYes
	 * @return AbstractCondition, welche in die KB eingefügt wurde
	 */
	private AbstractCondition handleAnswerYes(Question q) {
		CondChoiceYes c = new CondChoiceYes((QuestionYN)q);
		return c;
	}
	
	/**
	 * @param q Frage
	 * @param declaration Declaration der AnswerNo
	 * @return AbstractCondition, welche in die KB eingefügt wurde
	 */
	private AbstractCondition handleAnswerNo(Question q) {
		CondChoiceNo c = new CondChoiceNo((QuestionYN)q);
		return c;
	}
	
	/**
	 * @param q Frage
	 * @param declaration Declaration der AnswerUnknown
	 * @return AbstractCondition, welche in die KB eingefügt wurde
	 */
	private AbstractCondition handleAnswerUnknown(Question q) {
		CondUnknown c = new CondUnknown(q);
		return c;
	}
	
	/**
	 * @param c Kondition
	 * @param ql Frageliste, die mit dem Feuern der Kondition indiziert wird
	 */
	private void handleQuestionIndication(AbstractCondition c, List ql) {
	    if(c != null ) {
	    	if(ql.size() > 0) {
		        String newRuleID = kbm.findNewIDFor(new RuleComplex()); 
		        RuleFactory.createIndicationRule(newRuleID, ql, c);
		    }
	    } else {
			createMessage(t.line, t.col,
					"parser.decisionTree.error.conditionNull",
					Message.ERROR, t.val);
	    }
	    this.numberOfInsertedFollowingQuestions++;
	}
	
	/**
	 * @param c Kondition
	 * @param t Token der Frageklasse, die mit dem Feuern der Kondition indiziert wird
	 */
	private void handleQContainerIndication(AbstractCondition c, List qcl) {
		if(qcl.size() > 0) {
            String newRuleID = kbm.findNewIDFor(new RuleComplex());
            RuleFactory.createIndicationRule(newRuleID, qcl, c);
		    this.numberOfInsertedQContainerIndications += qcl.size();
		}
	}
	
	private static String KEY_DIAGNOSIS_NOT_FOUND = "parser.decisionTree.error.diagnosisNotFound";
	
	
	/**
	 * @param c Kondition 
	 * @param declarationToken Declaration der Diagnose, welche mit dem Feuern der Kondition indiziert wird
	 * @param indicationStrengthToken Token, der die Indikations-Stärke repräsentiert
	 * @return die gefundene Diagnose
	 */
	private Diagnosis handleDiagnosisIndication(AbstractCondition c, Token declarationToken, Token indicationStrengthToken){
		String declaration = formatDeclaration(declarationToken.val);
		Diagnosis diagnosis = kbm.findDiagnosis(declaration);
		String indicationStrength = formatDeclaration(indicationStrengthToken.val);
        if(diagnosis != null) {
            String newRuleID = kbm.findNewIDFor(new RuleComplex()); 
	        RuleFactory.createHeuristicPSRule(newRuleID, diagnosis, ScoreFinder.getScore(indicationStrength), c);
            //numberOfCreatedDiagnosisRules++;
        } else {
			createMessage(t.line, t.col,
					KEY_DIAGNOSIS_NOT_FOUND,
					Message.ERROR, declaration);
	    }
	    this.numberOfInsertedDiagnosisDerivations++;
	    return diagnosis;
	}
	
	/**
	 * Hier wird einer Liste von Frageklassen eine weitere Frageklasse hinzugefügt.
	 * @param declarationToken Declaration des QContainers (Frageklasse)
	 * @param qcl Frageklassen-Liste
	 */
	private void handleQContainerAccumulation(Token declarationToken, List qcl) {
		String declaration = formatDeclaration(declarationToken.val);
		QContainer qc = kbm.findQContainer(declaration);
		if (qc != null) {
			qcl.add(qc);
		} else {
			createMessage(t.line, t.col,
					"parser.decisionTree.error.qContainerNotFound",
					Message.ERROR, declaration);
		}
	}
	
	/**
	 * @param d Diagnose, welche eine Liste von Frageklassen indizieren soll.
	 * @param indicationStrengthToken Token der Indikations-Stärke
	 * @param qcl Liste der Frageklassen
	 */
	private void handleQContainerIndicationByDiagnosis(Diagnosis d, Token indicationStrengthToken, List qcl) {
		if (qcl.size() > 0) {
			String declarationStrength = formatDeclaration(indicationStrengthToken.val);
			Score score = ScoreFinder.getScore(declarationStrength);
			if (d != null) {
				List ruleList = d.getKnowledge(PSMethodNextQASet.class, MethodKind.FORWARD);
				// sollte normalerweise immer nur eine Regel haben!!!
				List existingQcl = null;
				if (ruleList != null){
					RuleComplex rc = (RuleComplex) ruleList.get(0);
					ActionNextQASet ra = (ActionNextQASet) rc.getAction();
					existingQcl = ra.getQASets();
				}
				// Die Regel muss erzeugt werden
				if(existingQcl == null || existingQcl.isEmpty()) {
					String newRuleID = kbm.findNewIDFor(new RuleComplex());
					if (score.compareTo(Score.P6) >= 0) {
						AbstractCondition c = new CondDState(d, DiagnosisState.ESTABLISHED, PSMethodHeuristic.class);
						RuleFactory.createRefinementRule(newRuleID, qcl, d, c);
					} else if (score.compareTo(Score.P3) >= 0) {
						AbstractCondition c = new CondDState(d, DiagnosisState.SUGGESTED, PSMethodHeuristic.class);
						RuleFactory.createClarificationRule(newRuleID, qcl, d, c);
					} else {
						AbstractCondition c = new CondDState(d, DiagnosisState.UNCLEAR, PSMethodHeuristic.class);
						RuleFactory.createIndicationRule(newRuleID, qcl, c);
						createMessage(t.line, t.col,
								"parser.decisionTree.warning.diagnosisStateUnclear",
								Message.WARNING, d.getText(), score.toString());
					}
					this.numberOfInsertedQContainerIndicationsByDiagnosis++;
				// Es muß ein Fehler geworfen werden, da die Listen nicht übereinstimmen!
				} else {
					boolean bool1 = existingQcl.containsAll(qcl);
					boolean bool2 = qcl.containsAll(existingQcl);
					if ( ! (bool1 && bool2)) {
						createMessage(t.line, t.col, "parser.decisionTree.error.differentQCLists", Message.ERROR, d.getText());
					} // else: Die Regel muss nicht erzeugt werden, da die Liste der QContainer übereinstimmt und bereits eine Regel existiert
				}
			} else {
				createMessage(t.line, t.col,
						"parser.decisionTree.error.diagnosisNotFound",
						Message.ERROR, "null");
			}
		}
	}
	
	private void handleQuestionIdentifier(Question q, String id){
		id = id.substring(1, id.length());
		id = id.trim();
		Question qSearch = kbm.findQuestion(id);
		if (qSearch == null) {
			q.setId(id);
		} else if (qSearch != q) {
			createMessage(t.line, t.col, "parser.decisionTree.error.idAlreadyExists", Message.ERROR, q.getText(), id);
		}
	}
	
	private String handleAnswerChoiceIdentifier(String id) {
		id = id.substring(1, id.length());
		id = id.trim();
		return id;
	}
	

	
	
CHARACTERS
newline = '\n' + '\r'.
zeroDigit                = '0'.
digitWithoutZero         = "123456789".
digit                    = zeroDigit + digitWithoutZero.

allowedDeclaration = ANY - '-' - '\n' - '\r' - '\"' - '[' - ']' - '(' - ')' - '{' - '}' - '<' - '>' - '=' - '#'.
allowedDeclarationFurther = allowedDeclaration + '-'.
allowedDeclarationNoSpace = allowedDeclaration - ' '.
allowedDeclarationFurtherNoSpace = allowedDeclarationFurther - ' '.
allowedDeclarationNoDigitNoSpace = allowedDeclarationNoSpace - digit.
allowedDeclarationFurtherWithBrackets = allowedDeclarationFurther + '\n' + '\r' + '[' + ']' + '(' + ')' + '{' + '}' + '<' + '>' + '=' + '#'.

commentChar = ANY - newline.

TOKENS
declaration			= (allowedDeclarationNoDigitNoSpace)
					| (allowedDeclarationNoDigitNoSpace {allowedDeclarationFurther} allowedDeclarationFurther)
//					| (allowedDeclarationNoSpace {allowedDeclarationFurther}allowedDeclarationFurtherNoDigitNoSpace)
//					| (allowedDeclarationNoSpace {allowedDeclarationFurther}allowedDeclarationFurtherNoDigitNoSpace{allowedDeclarationFurther}allowedDeclarationFurtherNoSpace)
					| ('\"' allowedDeclarationFurtherWithBrackets {allowedDeclarationFurtherWithBrackets} '\"')
					.
number				= ['-'](zeroDigit | digitWithoutZero{digit}) [('.' | ',') digit{digit}].
newline				= newline.
dash				= '-'.
parenthesisOpen     = '('.
parenthesisClose	= ')'.
bracketOpen			= '['.
bracketClose		= ']'.
ID					= '#'allowedDeclaration{allowedDeclaration}.


PRAGMAS
comment = "//"{commentChar}(newline){newline}.

// Die Token-Struktur wurde hier verbessert, der Parser ignoriert per default Spaces.
// Dies hat den Vorteil, das darauf nicht mehr geachtet werden muss, bzw. den Spaces nun keine syntaktische Funktion abverlangt wird.
// (siehe Frame-Dateien)
IGNORE '\t'

PRODUCTIONS
DecisionTree			=	{newline} QContainerDefinition
{IF(isNotEOF() && properAmountOfDashes(0)) Separator QContainerDefinition}
{newline} EOF.

QContainerDefinition    = Declaration											(.
																				String qContainerName = formatDeclaration(t.val);
																				QContainer q = handleQContainerDefinition(t);
																				.)																				
Question<out Question thisQ, q>
{IF(isFirstLevelQuestion())Question<out thisQ, q>}
																				(.
																				addSuccessNote(qContainerName);
																				.)
.

Question<out Question thisQ, QASet q> =
Separator																		(.
																				int l = countDashes();
																				.)
Dashes																				
Declaration																		(.
																				thisQ = null;
																				String d = formatDeclaration(t.val);
																				.)																			
(
QuestionNum<out thisQ, d, q, l>
| QuestionOC<out thisQ, d, q, l>
| QuestionMC<out thisQ, d, q, l>
| QuestionDate<out thisQ, d, q, l>
| QuestionText<out thisQ, d, q, l>
| QuestionYN<out thisQ, d, q, l>
)
{IF(properAmountOfDashes(l + 1))Question<out Question directChildQ, thisQ>}
.

QuestionNum<out Question thisQ, String d, QASet q, int l>	= "[num]"			(.
																				String unit = null;
																				.)
[
'{' Unit																		(.
																				unit = formatDeclaration(t.val);
																				.)
'}'
]
																				(.
																				Double intervalLeft = null;
																				Double intervalRight = null;
																				.)
[
'('
number																			(.
																				intervalLeft = Double.valueOf(t.val.replaceAll("," , "."));
																				.)
number																			(.																				
																				intervalRight = Double.valueOf(t.val.replaceAll("," , "."));
																				.)
')'																				
]																				(.
																				thisQ = handleQuestionNum(intervalLeft, intervalRight, d, unit, q);
																				.)
[IsAbstract<thisQ>]
[QuestionIdentifier<thisQ>]																																		
{IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerNum<thisQ>}.

QuestionOC<out Question thisQ, String d, QASet q, int l>           =   "[oc]"	(.
																				thisQ = handleQuestionOC(d, q);
																				.)
[IsAbstract<thisQ>]
[QuestionIdentifier<thisQ>]																																				
{IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerChoice<thisQ>}.

QuestionMC<out Question thisQ, String d, QASet q, int l>           =   "[mc]"	(.
																				thisQ = handleQuestionMC(d, q);
																				.)
[IsAbstract<thisQ>]
[QuestionIdentifier<thisQ>]																						
{IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerChoice<thisQ>}.

QuestionDate<out Question thisQ, String d, QASet q, int l>         =  "[date]"	(.
																				thisQ = handleQuestionDate(d, q);
																				.)
[IsAbstract<thisQ>]
[QuestionIdentifier<thisQ>]
{IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerDate<thisQ>}.

QuestionText<out Question thisQ, String d, QASet q, int l>         =  "[text]"	(.
																				thisQ = handleQuestionText(d, q);
																				.)
[IsAbstract<thisQ>]
[QuestionIdentifier<thisQ>]
{IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerText<thisQ>}.

QuestionYN<out Question thisQ, String d, QASet q, int l> =   ("[jn]" | "[yn]")	(.
																				thisQ = handleQuestionYN(d, q);
																				.)
[IsAbstract<thisQ>]
[QuestionIdentifier<thisQ>]																
[IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerYN<thisQ>]
[IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerYN<thisQ>]
[IF(properAmountOfDashes(l + 1) && !isFirstNonDeclarationToken("[", t))
AnswerYN<thisQ>]
.

AnswerNum<Question q>				=   										(.
																				int countDashes = countDashes();
																				.)
Separator Dashes Comparison<out AbstractCondition c, q>
																				(.
																				List qcl = new LinkedList();
																				List ql = new LinkedList();
																				boolean hasIndication = false;
																				.)																				
{IF(properAmountOfDashes(countDashes + 1))Indication<c, q, qcl, ql>
																				(.
																				hasIndication = true;
																				.)
}																				(.
																				handleQContainerIndication(c, qcl);
																				handleQuestionIndication(c, ql);
																				if (!hasIndication) createMessage(t.line, t.col,
																					"parser.decisionTree.warning.answerNotImportable",
																					Message.WARNING, q.getText());
																				.)
.

AnswerChoice<Question q>			=											(.
																				int countDashes = countDashes();
																				.)
Separator Dashes Declaration													(.
																				Token answerChoiceToken = t;
																				String answerChoiceId = kbm.findNewIDForAnswerChoice((QuestionChoice)q);
																				.)
[AnswerChoiceIdentifier<out answerChoiceId>]									(.
																				AbstractCondition c  = handleAnswerChoice(q, answerChoiceToken, answerChoiceId);
																				List qcl = new LinkedList();
																				List ql = new LinkedList();
																				.)																				
{IF(properAmountOfDashes(countDashes + 1))Indication<c, q, qcl, ql>}				
																				(.
																				handleQContainerIndication(c, qcl);
																				handleQuestionIndication(c, ql);
																				.)
.

AnswerDate<Question q>				=											(.
																				int countDashes = countDashes();
																				.)
Separator Dashes Declaration													(.
																				AbstractCondition c = handleAnswerDate(q, t);
																				.)
																				(.
																				List qcl = new LinkedList();
																				List ql = new LinkedList();
																				boolean hasIndication = false;
																				.)																				
{IF(properAmountOfDashes(countDashes + 1))Indication<c, q, qcl, ql>				(.
																				hasIndication = true;
																				.)
}																				(.
																				handleQContainerIndication(c, qcl);
																				handleQuestionIndication(c, ql);
																				if (!hasIndication) createMessage(t.line, t.col,
																					"parser.decisionTree.warning.answerNotImportable",
																					Message.WARNING, q.getText());
																				.)
.

AnswerText<Question q>					=										(.
																				int countDashes = countDashes();
																				.)
Separator Dashes Declaration													(.
																				AbstractCondition c = handleAnswerText(q, t);
																				.)
																				(.
																				List qcl = new LinkedList();
																				List ql = new LinkedList();
																				boolean hasIndication = false;
																				.)																				
{IF(properAmountOfDashes(countDashes + 1))Indication<c, q, qcl, ql>				(.
																				hasIndication = true;
																				.)
}																				(.
																				handleQContainerIndication(c, qcl);
																				handleQuestionIndication(c, ql);
																				if (!hasIndication) createMessage(t.line, t.col,
																					"parser.decisionTree.warning.answerNotImportable",
																					Message.WARNING, q.getText());
																				.)
.																				

AnswerYN<Question q>					=										(.
																				int countDashes = countDashes();
																				.)
Separator Dashes Declaration													(.
																				Token answerChoiceToken = t;
																				String declaration = formatDeclaration(answerChoiceToken.val);
																				AbstractCondition c = null;
																				if(declaration.equalsIgnoreCase("yes") || declaration.equalsIgnoreCase("ja")){
																					c = handleAnswerYes(q);
																				} else if(declaration.equalsIgnoreCase("no") || declaration.equalsIgnoreCase("nein")) {
																					c = handleAnswerNo(q);
																				} else if(declaration.equalsIgnoreCase("unknown") || declaration.equalsIgnoreCase("unbekannt")) {
																					c = handleAnswerUnknown(q);
																				} else {
																					createMessage(t.line, t.col,
																						"parser.decisionTree.error.wrongAnswerYNValue",
																						Message.ERROR, t.val);
																				}
																				.)
																				(.
																				List qcl = new LinkedList();
																				List ql = new LinkedList();
																				boolean hasIndication = false;
																				.)																				
{IF(properAmountOfDashes(countDashes + 1))Indication<c, q, qcl, ql>				(.
																				hasIndication = true;
																				.)
}																				(.
																				handleQContainerIndication(c, qcl);
																				handleQuestionIndication(c, ql);
																				if (!hasIndication) createMessage(t.line, t.col,
																					"parser.decisionTree.warning.answerNotImportable",
																					Message.WARNING, q.getText());
																				.)
.

Indication<AbstractCondition c, Question qParent, List qcl, List ql> =   
(
IF(isFirstNonDeclarationToken("[", t))
Question<out Question q, qParent>												(.
																				ql.add(q);
																				.)
|
IF(isFirstNonDeclarationToken("(", t))
Diagnosis<c>
|
QContainerIndication<qcl>
)
.
QContainerIndication<List qcl>    =
Separator Dashes Declaration													(.
																				handleQContainerAccumulation(t, qcl);
																				.)
.

Diagnosis<AbstractCondition c>               =									(.
																				int countDashes = countDashes();
																				.)
Separator Dashes Declaration													(.
																				Token declarationToken = t;
																				.)
'(' IndicationStrength															(.
																				Token indicationStrengthToken = t;
																				Diagnosis d = handleDiagnosisIndication(c, declarationToken, indicationStrengthToken);
																				.)
')'																				(.
																				List qcl = new LinkedList();
																				.)
{IF(properAmountOfDashes(countDashes + 1))										
QContainerIndicationByDiagnosis<qcl>
}																				(.
																				handleQContainerIndicationByDiagnosis(d, indicationStrengthToken, qcl);
																				.)
.
QContainerIndicationByDiagnosis<List qcl> = 
Separator Dashes Declaration													(.
																				handleQContainerAccumulation(t, qcl);
																				.)
.

Separator               =   SYNC newline{newline}.

Dashes                  =	dash												
{dash																			
}.

Declaration             =   declaration											
.

Unit				= declaration.

Comparison<out AbstractCondition c, Question q> =								(.
																				c = null;
																				.)
(															
'<'
number																			(.
																				handleComparison(q, t);
																				double answerValue = Double.parseDouble(t.val.replaceAll("," , "."));
																				c = new CondNumLess((QuestionNum)q, answerValue);
																				.)																				
| "<="
number																			(.
																				handleComparison(q, t);
																				double answerValue = Double.parseDouble(t.val.replaceAll("," , "."));
																				c = new CondNumLessEqual((QuestionNum)q, answerValue);																			
																				.)
| '>'
number																			(.
																				handleComparison(q, t);
																				double answerValue = Double.parseDouble(t.val.replaceAll("," , "."));
																				c = new CondNumGreater((QuestionNum)q, answerValue);																				
																				.)
| ">="
number																			(.
																				handleComparison(q, t);
																				double answerValue = Double.parseDouble(t.val.replaceAll("," , "."));
																				c = new CondNumGreaterEqual((QuestionNum)q, answerValue);																				
																				.)
| '='
number																			(.
																				handleComparison(q, t);
																				double answerValue = Double.parseDouble(t.val.replaceAll("," , "."));
																				c = new CondNumEqual((QuestionNum)q, answerValue);																				
																				.)
| 
bracketOpen
number																			(.
																				Token l = t;
																				.)
number																			(.
																				Token r = t;
																				handleComparison(q, l, r);
																				double intervalLeft = Double.parseDouble(l.val.replaceAll("," , "."));
																				double intervalRight = Double.parseDouble(r.val.replaceAll("," , "."));																				
																				c = new CondNumIn((QuestionNum)q, intervalLeft, intervalRight);																				
																				.)
bracketClose																				
)
.

IndicationStrength  =
"N1" | "N2" | "N3" | "N4" | "N5" | "N5+"										(.
																				t.val = "N5x";
																				.)
| "N6" | "N7"
| "P1" | "P2" | "P3" | "P4" | "P5" | "P5+"										(.
																				t.val = "P5x";
																				.)
| "P6" | "P7"
| '+'																			(.
																				t.val = "P1";
																				.)
| "++"																			(.
																				t.val = "P4";
																				.)
| "+++"																			(.
																				t.val = "P7";
																				.)
| dash																			(.
																				t.val = "N1";
																				.)
[dash																			(.
																				t.val = "N4";
																				.)
[dash																			(.
																				t.val = "N7";
																				.)
]] 
.

IsAbstract<Question q> = ("<abstrakt>" | "<abstract>")							(.													
																				handleQuestionAbstract(q);
																				.)
.																				
QuestionIdentifier<Question q> = ID												(.
																				handleQuestionIdentifier(q, t.val);
																				.)
.
AnswerChoiceIdentifier<out String answerChoiceId> = ID
																				(.
																				answerChoiceId = handleAnswerChoiceIdentifier(t.val);
																				.)
.																																				

END DecisionTree.






















